<!DOCTYPE html>
<html class="no-js" lang="fr">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>[WPF] Utiliser les InputBindings avec le pattern MVVM - Blog .NET de Thomas Levesque</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
	<meta property="og:title" content="[WPF] Utiliser les InputBindings avec le pattern MVVM" />
<meta property="og:description" content="Si vous développez des applications WPF en suivant le design pattern Model-View-ViewModel, vous vous êtes peut-être déjà trouvé confronté au problème suivant : comment, en XAML, lier un raccourci clavier ou une action de la souris à une commande du ViewModel ? Idéalement, on aimerait pouvoir faire comme ça :
&lt;UserControl.InputBindings&gt; &lt;KeyBinding Modifiers=&#34;Control&#34; Key=&#34;E&#34; Command=&#34;{Binding EditCommand}&#34;/&gt; &lt;/UserControl.InputBindings&gt; Malheureusement, ce code ne fonctionne pas, pour deux raisons :
 La propriété Command n&#39;est pas une DependencyProperty, on ne peut donc pas faire de binding dessus Les InputBindings ne font pas partie de l&#39;arbre logique ou visuel du contrôle, ils n&#39;héritent donc pas du DataContext  Une solution, bien sûr, serait de passer par le code-behind pour créer les InputBindings, mais en général, dans une application développée selon le pattern MVVM, on préfère éviter d&#39;écrire du code-behind." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://thomaslevesque.fr/2009/03/17/wpf-utiliser-les-inputbindings-avec-le-pattern-mvvm/" />
<meta property="article:published_time" content="2009-03-17T00:00:00+00:00" />
<meta property="article:modified_time" content="2009-03-17T00:00:00+00:00" />

	<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="[WPF] Utiliser les InputBindings avec le pattern MVVM"/>
<meta name="twitter:description" content="Si vous développez des applications WPF en suivant le design pattern Model-View-ViewModel, vous vous êtes peut-être déjà trouvé confronté au problème suivant : comment, en XAML, lier un raccourci clavier ou une action de la souris à une commande du ViewModel ? Idéalement, on aimerait pouvoir faire comme ça :
&lt;UserControl.InputBindings&gt; &lt;KeyBinding Modifiers=&#34;Control&#34; Key=&#34;E&#34; Command=&#34;{Binding EditCommand}&#34;/&gt; &lt;/UserControl.InputBindings&gt; Malheureusement, ce code ne fonctionne pas, pour deux raisons :
 La propriété Command n&#39;est pas une DependencyProperty, on ne peut donc pas faire de binding dessus Les InputBindings ne font pas partie de l&#39;arbre logique ou visuel du contrôle, ils n&#39;héritent donc pas du DataContext  Une solution, bien sûr, serait de passer par le code-behind pour créer les InputBindings, mais en général, dans une application développée selon le pattern MVVM, on préfère éviter d&#39;écrire du code-behind."/>

	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">
	<link rel="stylesheet" href="/css/style.css">
	<link rel="stylesheet" href="/css/social.css">
	<link rel="shortcut icon" href="/favicon.ico">
		
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-31645024-1', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>

</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container">
		<div class="logo">
			<a class="logo__link" href="/" title="Blog .NET de Thomas Levesque" rel="home">
				<div class="logo__title">Blog .NET de Thomas Levesque</div>
				<div class="logo__tagline">Nouveautés, découvertes, réflexions, trucs, astuces en tous genres sur les technologies .NET</div>
			</a>
		</div>
		
<nav class="menu">
	<button class="menu__btn" aria-haspopup="true" aria-expanded="false" tabindex="0">
		<span class="menu__btn-title" tabindex="-1">Menu</span>
	</button>
	<ul class="menu__list">
		<li class="menu__item">
			<a class="menu__link" href="/a-propos/">
				
				<span class="menu__text">À propos</span>
				
			</a>
		</li>
	</ul>
</nav>

	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">[WPF] Utiliser les InputBindings avec le pattern MVVM</h1>
			<div class="post__meta meta">
<div class="meta__item-datetime meta__item">
	<svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class="meta__text" datetime="2009-03-17T00:00:00Z">March 17, 2009</time></div></div>
		</header><div class="content post__content clearfix">
			<p>Si vous développez des applications WPF en suivant le design pattern Model-View-ViewModel, vous vous êtes peut-être déjà trouvé confronté au problème suivant : comment, en XAML, lier un raccourci clavier ou une action de la souris à une commande du ViewModel ? Idéalement, on aimerait pouvoir faire comme ça :</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-xml" data-lang="xml">    <span style="color:#f92672">&lt;UserControl.InputBindings</span><span style="color:#f92672">&gt;</span>
        <span style="color:#f92672">&lt;KeyBinding</span> <span style="color:#a6e22e">Modifiers=</span><span style="color:#e6db74">&#34;Control&#34;</span> <span style="color:#a6e22e">Key=</span><span style="color:#e6db74">&#34;E&#34;</span> <span style="color:#a6e22e">Command=</span><span style="color:#e6db74">&#34;{Binding EditCommand}&#34;</span><span style="color:#f92672">/&gt;</span>
    <span style="color:#f92672">&lt;/UserControl.InputBindings&gt;</span>
</code></pre></div><p>Malheureusement, ce code ne fonctionne pas, pour deux raisons :</p>
<ol>
<li>La propriété Command n'est pas une DependencyProperty, on ne peut donc pas faire de binding dessus</li>
<li>Les InputBindings ne font pas partie de l'arbre logique ou visuel du contrôle, ils n'héritent donc pas du DataContext</li>
</ol>
<p>Une solution, bien sûr, serait de passer par le code-behind pour créer les InputBindings, mais en général, dans une application développée selon le pattern MVVM, on préfère éviter d'écrire du code-behind. J'ai longuement cherché des solutions alternatives pour pouvoir le faire en XAML, mais la plupart sont relativement complexes et peu intuitives. J'ai donc finalement créé une markup extension qui permet de se binder à une commande du DataContext, à n'importe quel endroit du code XAML, même si l'élément n'hérite pas du DataContext.  Cette extension s'utilise comme un simple binding :</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-xml" data-lang="xml">    <span style="color:#f92672">&lt;UserControl.InputBindings</span><span style="color:#f92672">&gt;</span>
        <span style="color:#f92672">&lt;KeyBinding</span> <span style="color:#a6e22e">Modifiers=</span><span style="color:#e6db74">&#34;Control&#34;</span> <span style="color:#a6e22e">Key=</span><span style="color:#e6db74">&#34;E&#34;</span> <span style="color:#a6e22e">Command=</span><span style="color:#e6db74">&#34;{input:CommandBinding EditCommand}&#34;</span><span style="color:#f92672">/&gt;</span>
    <span style="color:#f92672">&lt;/UserControl.InputBindings&gt;</span>
</code></pre></div><p>(Le namespace XML <em>input</em> étant mappé sur le namespace CLR où est déclarée la markup extension)  Pour réaliser cette extension, j'avoue que j'ai un peu triché&hellip; j'ai fouillé avec Reflector le code des classes de WPF, afin de trouver des champs privés qui permettraient de récupérer le DataContext de l'élément racine. J'accède ensuite à ces champs par réflexion.  Voici le code :</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp"><span style="color:#66d9ef">using</span> System;
<span style="color:#66d9ef">using</span> System.Reflection;
<span style="color:#66d9ef">using</span> System.Windows;
<span style="color:#66d9ef">using</span> System.Windows.Input;
<span style="color:#66d9ef">using</span> System.Windows.Markup;

<span style="color:#66d9ef">namespace</span> MVVMLib.Input
{
<span style="color:#a6e22e">    [MarkupExtensionReturnType(typeof(ICommand))]</span>
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">CommandBindingExtension</span> : MarkupExtension
    {
        <span style="color:#66d9ef">public</span> CommandBindingExtension()
        {
        }

        <span style="color:#66d9ef">public</span> CommandBindingExtension(<span style="color:#66d9ef">string</span> commandName)
        {
            <span style="color:#66d9ef">this</span>.CommandName = commandName;
        }
<span style="color:#a6e22e">
</span><span style="color:#a6e22e">        [ConstructorArgument(&#34;commandName&#34;)]</span>
        <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">string</span> CommandName { <span style="color:#66d9ef">get</span>; <span style="color:#66d9ef">set</span>; }

        <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">object</span> targetObject;
        <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">object</span> targetProperty;

        <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">override</span> <span style="color:#66d9ef">object</span> ProvideValue(IServiceProvider serviceProvider)
        {
            IProvideValueTarget provideValueTarget = serviceProvider.GetService(<span style="color:#66d9ef">typeof</span>(IProvideValueTarget)) <span style="color:#66d9ef">as</span> IProvideValueTarget;
            <span style="color:#66d9ef">if</span> (provideValueTarget != <span style="color:#66d9ef">null</span>)
            {
                targetObject = provideValueTarget.TargetObject;
                targetProperty = provideValueTarget.TargetProperty;
            }

            <span style="color:#66d9ef">if</span> (!<span style="color:#66d9ef">string</span>.IsNullOrEmpty(CommandName))
            {
                <span style="color:#75715e">// The serviceProvider is actually a ProvideValueServiceProvider, which has a private field &#34;_context&#34; of type ParserContext
</span><span style="color:#75715e"></span>                ParserContext parserContext = GetPrivateFieldValue&lt;ParserContext&gt;(serviceProvider, <span style="color:#e6db74">&#34;_context&#34;</span>);
                <span style="color:#66d9ef">if</span> (parserContext != <span style="color:#66d9ef">null</span>)
                {
                    <span style="color:#75715e">// A ParserContext has a private field &#34;_rootElement&#34;, which returns the root element of the XAML file
</span><span style="color:#75715e"></span>                    FrameworkElement rootElement = GetPrivateFieldValue&lt;FrameworkElement&gt;(parserContext, <span style="color:#e6db74">&#34;_rootElement&#34;</span>);
                    <span style="color:#66d9ef">if</span> (rootElement != <span style="color:#66d9ef">null</span>)
                    {
                        <span style="color:#75715e">// Now we can retrieve the DataContext
</span><span style="color:#75715e"></span>                        <span style="color:#66d9ef">object</span> dataContext = rootElement.DataContext;

                        <span style="color:#75715e">// The DataContext may not be set yet when the FrameworkElement is first created, and it may change afterwards,
</span><span style="color:#75715e"></span>                        <span style="color:#75715e">// so we handle the DataContextChanged event to update the Command when needed
</span><span style="color:#75715e"></span>                        <span style="color:#66d9ef">if</span> (!dataContextChangeHandlerSet)
                        {
                            rootElement.DataContextChanged += <span style="color:#66d9ef">new</span> DependencyPropertyChangedEventHandler(rootElement_DataContextChanged);
                            dataContextChangeHandlerSet = <span style="color:#66d9ef">true</span>;
                        }

                        <span style="color:#66d9ef">if</span> (dataContext != <span style="color:#66d9ef">null</span>)
                        {
                            ICommand command = GetCommand(dataContext, CommandName);
                            <span style="color:#66d9ef">if</span> (command != <span style="color:#66d9ef">null</span>)
                                <span style="color:#66d9ef">return</span> command;
                        }
                    }
                }
            }

            <span style="color:#75715e">// The Command property of an InputBinding cannot be null, so we return a dummy extension instead
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">return</span> DummyCommand.Instance;
        }

        <span style="color:#66d9ef">private</span> ICommand GetCommand(<span style="color:#66d9ef">object</span> dataContext, <span style="color:#66d9ef">string</span> commandName)
        {
            PropertyInfo prop = dataContext.GetType().GetProperty(commandName);
            <span style="color:#66d9ef">if</span> (prop != <span style="color:#66d9ef">null</span>)
            {
                ICommand command = prop.GetValue(dataContext, <span style="color:#66d9ef">null</span>) <span style="color:#66d9ef">as</span> ICommand;
                <span style="color:#66d9ef">if</span> (command != <span style="color:#66d9ef">null</span>)
                    <span style="color:#66d9ef">return</span> command;
            }
            <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">null</span>;
        }

        <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">void</span> AssignCommand(ICommand command)
        {
            <span style="color:#66d9ef">if</span> (targetObject != <span style="color:#66d9ef">null</span> &amp;&amp; targetProperty != <span style="color:#66d9ef">null</span>)
            {
                <span style="color:#66d9ef">if</span> (targetProperty <span style="color:#66d9ef">is</span> DependencyProperty)
                {
                    DependencyObject depObj = targetObject <span style="color:#66d9ef">as</span> DependencyObject;
                    DependencyProperty depProp = targetProperty <span style="color:#66d9ef">as</span> DependencyProperty;
                    depObj.SetValue(depProp, command);
                }
                <span style="color:#66d9ef">else</span>
                {
                    PropertyInfo prop = targetProperty <span style="color:#66d9ef">as</span> PropertyInfo;
                    prop.SetValue(targetObject, command, <span style="color:#66d9ef">null</span>);
                }
            }
        }

        <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">bool</span> dataContextChangeHandlerSet = <span style="color:#66d9ef">false</span>;
        <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">void</span> rootElement_DataContextChanged(<span style="color:#66d9ef">object</span> sender, DependencyPropertyChangedEventArgs e)
        {
            FrameworkElement rootElement = sender <span style="color:#66d9ef">as</span> FrameworkElement;
            <span style="color:#66d9ef">if</span> (rootElement != <span style="color:#66d9ef">null</span>)
            {
                <span style="color:#66d9ef">object</span> dataContext = rootElement.DataContext;
                <span style="color:#66d9ef">if</span> (dataContext != <span style="color:#66d9ef">null</span>)
                {
                    ICommand command = GetCommand(dataContext, CommandName);
                    <span style="color:#66d9ef">if</span> (command != <span style="color:#66d9ef">null</span>)
                    {
                        AssignCommand(command);
                    }
                }
            }
        }

        <span style="color:#66d9ef">private</span> T GetPrivateFieldValue&lt;T&gt;(<span style="color:#66d9ef">object</span> target, <span style="color:#66d9ef">string</span> fieldName)
        {
            FieldInfo field = target.GetType().GetField(fieldName, BindingFlags.Instance | BindingFlags.NonPublic);
            <span style="color:#66d9ef">if</span> (field != <span style="color:#66d9ef">null</span>)
            {
                <span style="color:#66d9ef">return</span> (T)field.GetValue(target);
            }
            <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">default</span>(T);
        }

        <span style="color:#75715e">// A dummy command that does nothing...
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">DummyCommand</span> : ICommand
        {

            <span style="color:#75715e">#region Singleton pattern
</span><span style="color:#75715e"></span>
            <span style="color:#66d9ef">private</span> DummyCommand()
            {
            }

            <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> DummyCommand _instance = <span style="color:#66d9ef">null</span>;
            <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> DummyCommand Instance
            {
                <span style="color:#66d9ef">get</span>
                {
                    <span style="color:#66d9ef">if</span> (_instance == <span style="color:#66d9ef">null</span>)
                    {
                        _instance = <span style="color:#66d9ef">new</span> DummyCommand();
                    }
                    <span style="color:#66d9ef">return</span> _instance;
                }
            }

            <span style="color:#75715e">#endregion
</span><span style="color:#75715e"></span>
            <span style="color:#75715e">#region ICommand Members
</span><span style="color:#75715e"></span>
            <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">bool</span> CanExecute(<span style="color:#66d9ef">object</span> parameter)
            {
                <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span>;
            }

            <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">event</span> EventHandler CanExecuteChanged;

            <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> Execute(<span style="color:#66d9ef">object</span> parameter)
            {
            }

            <span style="color:#75715e">#endregion
</span><span style="color:#75715e"></span>        }
    }
</code></pre></div><p>Cette solution a cependant une limitation : elle ne fonctionne que pour le DataContext de la racine du XAML. On ne peut donc pas l'utiliser, par exemple, pour définir des InputBindings sur un contrôle dont on redéfinit aussi le DataContext, car la markup extension renverra le DataContext de l'élément racine.</p>

		</div>
		<footer class="post__footer">
			
<div class="post__tags tags clearfix">
	<svg class="tags__badge icon icon-tag" width="16" height="16" viewBox="0 0 32 32"><path d="M32 19c0 1-1 2-1 2L21 31s-1 1-2 1-2-1-2-1L2 16c-1-1-1.4-2-1.4-2S0 12.5 0 11V3C0 1.5.8.8.8.8S1.5 0 3 0h8c1.5 0 3 .6 3 .6S15 1 16 2l15 15s1 1 1 2zM7 10a3 3 0 1 0 0-6 3 3 0 0 0 0 6z"/></svg>
	<ul class="tags__list">
		<li class="tags__item">
			<a class="tags__link btn" href="/tags/inputbinding/" rel="tag">InputBinding</a>
		</li>
		<li class="tags__item">
			<a class="tags__link btn" href="/tags/keybinding/" rel="tag">KeyBinding</a>
		</li>
		<li class="tags__item">
			<a class="tags__link btn" href="/tags/markup-extension/" rel="tag">markup extension</a>
		</li>
		<li class="tags__item">
			<a class="tags__link btn" href="/tags/mvvm/" rel="tag">MVVM</a>
		</li>
		<li class="tags__item">
			<a class="tags__link btn" href="/tags/wpf/" rel="tag">WPF</a>
		</li>
		<li class="tags__item">
			<a class="tags__link btn" href="/tags/xaml/" rel="tag">XAML</a>
		</li>
	</ul>
</div>
		</footer>
	</article>
</main>

<div class="authorbox clearfix">
	<figure class="authorbox__avatar">
		<img alt="Thomas Levesque avatar" src="/images/avatar.jpg" class="avatar" height="90" width="90">
	</figure>
	<div class="authorbox__header">
		<span class="authorbox__name">À propos Thomas Levesque</span>
	</div>
	<div class="authorbox__description">
		Thomas Levesque est un développeur français vivant à Paris.
	</div>
</div>

<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/2009/03/05/visual-studio-astuce-definir-un-element-du-projet-comme-sous-element-dun-autre/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Précédent</span>
			<p class="pager__title">[Visual Studio] Astuce : définir un élément du projet comme sous-élément d&#39;un autre</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/2009/03/27/wpf-tri-automatique-dun-gridview-lors-du-clic-sur-une-colonne/" rel="next">
			<span class="pager__subtitle">Suivant&thinsp;»</span>
			<p class="pager__title">[WPF] Tri automatique d&#39;un GridView lors du clic sur une colonne</p>
		</a>
	</div>
</nav>

<div>
    <script src="https://utteranc.es/client.js"
            repo="thomaslevesque/blog-fr"
            issue-term="pathname"
            label="post-comment"
            theme="github-light"
            crossorigin="anonymous"
            async>
    </script>
</div>


			</div>
			<aside class="sidebar"><div class="widget-search widget">
	<form class="widget-search__form" role="search" method="get" action="https://google.com/search">
		<label>
			<input class="widget-search__field" type="search" placeholder="Rechercher..." value="" name="q" aria-label="Rechercher...">
		</label>
		<input class="widget-search__submit" type="submit" value="Search">
		<input type="hidden" name="sitesearch" value="https://thomaslevesque.fr/" />
	</form>
</div>
<div class="widget-social widget">
    <h4 class="widget-social__title widget__title">Social</h4>
    <div class="widget-social__content widget__content">
        <a class="widget-social__link-custom widget__link" title="GitHub" rel="noopener noreferrer" href="https://github.com/thomaslevesque" target="_blank">
            <svg class="widget-social__link-icon-custom icon icon-github" width="24" height="24" viewBox="0 0 384 374"><path d="m192 0c-106.1 0-192 85.8-192 191.7 0 84.7 55 156.6 131.3 181.9 9.6 1.8 13.1-4.2 13.1-9.2 0-4.6-.2-16.6-.3-32.6-53.4 11.6-64.7-25.7-64.7-25.7-8.7-22.1-21.3-28-21.3-28-17.4-11.9 1.3-11.6 1.3-11.6 19.3 1.4 29.4 19.8 29.4 19.8 17.1 29.3 44.9 20.8 55.9 15.9 1.7-12.4 6.7-20.8 12.2-25.6-42.6-4.8-87.5-21.3-87.5-94.8 0-20.9 7.5-38 19.8-51.4-2-4.9-8.6-24.3 1.9-50.7 0 0 16.1-5.2 52.8 19.7 15.3-4.2 31.7-6.4 48.1-6.5 16.3.1 32.7 2.2 48.1 6.5 36.7-24.8 52.8-19.7 52.8-19.7 10.5 26.4 3.9 45.9 1.9 50.7 12.3 13.4 19.7 30.5 19.7 51.4 0 73.7-44.9 89.9-87.7 94.6 6.9 5.9 13 17.6 13 35.5 0 25.6-.2 46.3-.2 52.6 0 5.1 3.5 11.1 13.2 9.2 76.2-25.5 131.2-97.3 131.2-182 0-105.9-86-191.7-192-191.7z"/></svg>
        </a>
        <a class="widget-social__link-custom widget__link" title="Twitter" rel="noopener noreferrer" href="https://twitter.com/thomaslevesque" target="_blank">
            <svg class="widget-social__link-icon-custom icon icon-twitter" width="24" height="24" viewBox="0 0 384 312"><path d="m384 36.9c-14.1 6.3-29.3 10.5-45.2 12.4 16.3-9.7 28.8-25.2 34.6-43.6-15.2 9-32.1 15.6-50 19.1-14.4-15.2-34.9-24.8-57.5-24.8-43.5 0-78.8 35.3-78.8 78.8 0 6.2.7 12.2 2 17.9-65.5-3.3-123.5-34.6-162.4-82.3-6.7 11.6-10.6 25.2-10.6 39.6 0 27.3 13.9 51.4 35 65.6-12.9-.4-25.1-4-35.7-9.9v1c0 38.2 27.2 70 63.2 77.2-6.6 1.8-13.6 2.8-20.8 2.8-5.1 0-10-.5-14.8-1.4 10 31.3 39.1 54.1 73.6 54.7-27 21.1-60.9 33.7-97.8 33.7-6.4 0-12.6-.4-18.8-1.1 34.9 22.4 76.3 35.4 120.8 35.4 144.9 0 224.1-120 224.1-224.1 0-3.4-.1-6.8-.2-10.2 15.4-11.1 28.7-25 39.3-40.8z"/></svg>
        </a>
    </div>
</div>
<div class="widget-recent widget">
	<h4 class="widget__title">Articles récents</h4>
	<div class="widget__content">
		<ul class="widget__list">
			<li class="widget__item"><a class="widget__link" href="/2018/04/17/fin-de-mon-blog-en-francais/">Fin de mon blog en français</a></li>
			<li class="widget__item"><a class="widget__link" href="/2018/03/27/comprendre-le-pipeline-de-middleware-dasp-net-core/">Comprendre le pipeline de middleware d&#39;ASP.NET Core</a></li>
			<li class="widget__item"><a class="widget__link" href="/2018/03/06/nettoyer-lhistorique-dune-branche-git-pour-supprimer-les-fichiers-indesirables/">Nettoyer l&#39;historique d&#39;une branche Git pour supprimer les fichiers indésirables</a></li>
			<li class="widget__item"><a class="widget__link" href="/2018/02/25/meilleure-gestion-du-timeout-avec-httpclient/">Meilleure gestion du timeout avec HttpClient</a></li>
			<li class="widget__item"><a class="widget__link" href="/2017/11/14/transformer-les-templates-t4-pendant-la-build-et-passer-des-variables-du-projet/">Transformer les templates T4 pendant la build, et passer des variables du projet</a></li>
		</ul>
	</div>
</div>
<div class="widget-taglist widget">
	<h4 class="widget__title">Mots-clefs</h4>
	<div class="widget__content">
		<a class="widget-taglist__link widget__link btn" href="/tags/c%23/" title="c#">c#</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/wpf/" title="wpf">wpf</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/xaml/" title="xaml">xaml</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/visual-studio/" title="visual-studio">visual-studio</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/async/" title="async">async</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/binding/" title="binding">binding</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/markup-extension/" title="markup-extension">markup-extension</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/mvvm/" title="mvvm">mvvm</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/linq/" title="linq">linq</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/tests-unitaires/" title="tests-unitaires">tests-unitaires</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/winrt/" title="winrt">winrt</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/.net/" title=".net">.net</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/.net-4.0/" title=".net-4.0">.net-4.0</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/.net-core/" title=".net-core">.net-core</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/asynchrone/" title="asynchrone">asynchrone</a>
	</div>
</div>
</aside>
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2020 Thomas Levesque.
			<span class="footer__copyright-credits">Produit par <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> et le thème <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a>.</span>
		</div>
	</div>
</footer>
	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>