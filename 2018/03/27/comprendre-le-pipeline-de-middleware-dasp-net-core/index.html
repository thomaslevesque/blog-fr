<!DOCTYPE html>
<html class="no-js" lang="fr">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>Comprendre le pipeline de middleware d&#39;ASP.NET Core - Blog .NET de Thomas Levesque</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
	<meta property="og:title" content="Comprendre le pipeline de middleware d&#39;ASP.NET Core" />
<meta property="og:description" content="Middlewhat? L&#39;architecture d&#39;ASP.NET Core est basée sur un système de middlewares, des morceaux de code qui gèrent les requêtes et réponses. Les middlewares sont chainés les uns aux autres pour constituer un pipeline. Les requêtes entrantes passent dans le pipeline, où chaque middleware a l&#39;occasion de les examiner et/ou de les modifier avant des les passer au middleware suivant. Les réponses sortantes passent aussi dans le pipeline, dans l&#39;ordre inverse. Si tout cela semble très abstrait, le schéma suivant, tiré de la documentation officielle ASP." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://thomaslevesque.fr/2018/03/27/comprendre-le-pipeline-de-middleware-dasp-net-core/" />
<meta property="article:published_time" content="2018-03-27T00:00:00+00:00" />
<meta property="article:modified_time" content="2018-03-27T00:00:00+00:00" />

	<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Comprendre le pipeline de middleware d&#39;ASP.NET Core"/>
<meta name="twitter:description" content="Middlewhat? L&#39;architecture d&#39;ASP.NET Core est basée sur un système de middlewares, des morceaux de code qui gèrent les requêtes et réponses. Les middlewares sont chainés les uns aux autres pour constituer un pipeline. Les requêtes entrantes passent dans le pipeline, où chaque middleware a l&#39;occasion de les examiner et/ou de les modifier avant des les passer au middleware suivant. Les réponses sortantes passent aussi dans le pipeline, dans l&#39;ordre inverse. Si tout cela semble très abstrait, le schéma suivant, tiré de la documentation officielle ASP."/>

	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">
	<link rel="stylesheet" href="/css/style.css">
	<link rel="stylesheet" href="/css/social.css">
	<link rel="shortcut icon" href="/favicon.ico">
		
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-31645024-1', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>

</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container">
		<div class="logo">
			<a class="logo__link" href="/" title="Blog .NET de Thomas Levesque" rel="home">
				<div class="logo__title">Blog .NET de Thomas Levesque</div>
				<div class="logo__tagline">Nouveautés, découvertes, réflexions, trucs, astuces en tous genres sur les technologies .NET</div>
			</a>
		</div>
		
<nav class="menu">
	<button class="menu__btn" aria-haspopup="true" aria-expanded="false" tabindex="0">
		<span class="menu__btn-title" tabindex="-1">Menu</span>
	</button>
	<ul class="menu__list">
		<li class="menu__item">
			<a class="menu__link" href="/a-propos/">
				
				<span class="menu__text">À propos</span>
				
			</a>
		</li>
	</ul>
</nav>

	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Comprendre le pipeline de middleware d&#39;ASP.NET Core</h1>
			<div class="post__meta meta">
<div class="meta__item-datetime meta__item">
	<svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class="meta__text" datetime="2018-03-27T00:00:00Z">March 27, 2018</time></div></div>
		</header><div class="content post__content clearfix">
			<h2 id="middlewhat">Middlewhat?</h2>
<p>L'architecture d'ASP.NET Core est basée sur un système de <strong>middlewares</strong>, des morceaux de code qui gèrent les requêtes et réponses. Les middlewares sont chainés les uns aux autres pour constituer un <strong>pipeline</strong>. Les requêtes entrantes passent dans le pipeline, où chaque middleware a l'occasion de les examiner et/ou de les modifier avant des les passer au middleware suivant. Les réponses sortantes passent aussi dans le pipeline, dans l'ordre inverse. Si tout cela semble très abstrait, le schéma suivant, tiré de la <a href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/middleware">documentation officielle ASP.NET Core</a>, devrait aider à comprendre :  <img src="request-delegate-pipeline.png" alt="Middleware pipeline">  Les middlewares peuvent faire toutes sortent de choses, comme gérer l'authentification, les erreurs, les fichiers statiques, etc. La couche MVC d'ASP.NET Core est également implémentée comme un middleware.</p>
<h2 id="configurer-le-pipeline">Configurer le pipeline</h2>
<p>On configure habituellement le pipeline ASP.NET Core dans la méthode <code>Configure</code> de la classe <code>Startup</code>, en appelant des méthodes <code>Use*</code> sur le <code>IApplicationBuilder</code>. Voici un exemple tiré de la documentation :</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> Configure(IApplicationBuilder app)
{
    app.UseExceptionHandler(<span style="color:#e6db74">&#34;/Home/Error&#34;</span>);
    app.UseStaticFiles();
    app.UseAuthentication();
    app.UseMvcWithDefaultRoute();
}
</code></pre></div><p>Chaque méthode <code>Use*</code> ajoute un middleware au pipeline. L'ordre dans lequel ils sont ajoutés détermine l'ordre dans lequel les requêtes les traverseront. Dans cet exemple, une requête entrante va d'abord passer par le middleware de gestion d'exception, puis par le middleware de fichiers statiques, puis par le middleware d'authentification, et sera finalement gérée par le middleware MVC.  Les méthodes <code>Use*</code> dans cet exemple sont en fait juste des raccourcis pour faciliter la construction du pipeline. Sous le capot, elles finissent toutes par appeler, directement ou indirectement, les primitives de bas niveau suivantes : <code>Use</code> et <code>Run</code>. Ces deux méthodes ajoutent un middleware au pipeline, la différence est que <code>Run</code> ajoute un middleware <em>terminal</em>, c'est à dire qui est le dernier du pipeline.</p>
<h2 id="un-pipeline-basique-sans-branches">Un pipeline basique sans branches</h2>
<p>Regardons d'abord un exemple simple, qui utilise simplement les primitives <code>Use</code> et <code>Run</code> :</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> Configure(IApplicationBuilder app)
{
    <span style="color:#75715e">// Middleware A
</span><span style="color:#75715e"></span>    app.Use(<span style="color:#66d9ef">async</span> (context, next) =&gt;
    {
        Console.WriteLine(<span style="color:#e6db74">&#34;A (before)&#34;</span>);
        <span style="color:#66d9ef">await</span> next();
        Console.WriteLine(<span style="color:#e6db74">&#34;A (after)&#34;</span>);
    });

    <span style="color:#75715e">// Middleware B
</span><span style="color:#75715e"></span>    app.Use(<span style="color:#66d9ef">async</span> (context, next) =&gt;
    {
        Console.WriteLine(<span style="color:#e6db74">&#34;B (before)&#34;</span>);
        <span style="color:#66d9ef">await</span> next();
        Console.WriteLine(<span style="color:#e6db74">&#34;B (after)&#34;</span>);
    });

    <span style="color:#75715e">// Middleware C (terminal)
</span><span style="color:#75715e"></span>    app.Run(<span style="color:#66d9ef">async</span> context =&gt;
    {
        Console.WriteLine(<span style="color:#e6db74">&#34;C&#34;</span>);
        <span style="color:#66d9ef">await</span> context.Response.WriteAsync(<span style="color:#e6db74">&#34;Hello world&#34;</span>);
    });
}
</code></pre></div><p>Ici, les middleware sont définis &ldquo;inline&rdquo; avec des méthodes anonymes ; ils pourraient aussi être définis commes des classes complètes, mais pour cet exemple j'ai opté pour la forme la plus concise. Les middleware non-terminaux prennent deux arguments : le <code>HttpContext</code> et un delegate qui appelle le middleware suivant. Le middleware terminal prend seulement le <code>HttpContext</code>. Ici on a deux middlewares non-terminaux A et B qui écrivent simplement dans la console, et un middleware terminal C qui écrit la réponse.  Voici la sortie console quand on envoie une requête à l'application :</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">A (before)
B (before)
C
B (after)
A (after)
</code></pre></div><p>On voit que chaque middleware est traversé dans l'ordre dans lequel il a été ajouté, puis traversé à nouveau en sens inverse. Le pipeline peut être représenté comme suit :  <img src="basic-pipeline.png" alt="Basic pipeline"></p>
<h2 id="court-circuiter-le-pipeline">Court-circuiter le pipeline</h2>
<p>Un middleware n'est pas obligé d'appeler le middleware suivant. Par exemple, si le middleware de fichiers statiques peut gérer une requête, il n'a pas besoin de la passer au reste du pipeline, il peut répondre immédiatement. Ce comportement s'appelle &ldquo;court-circuiter le pipeline&rdquo;.  Dans l'exemple précédent, si on commente l'appel à <code>next()</code> dans le middleware B, on obtient la sortie suivante :</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">A (before)
B (before)
B (after)
A (after)
</code></pre></div><p>Comme vous pouvez le voir, le middleware C n'est jamais appelé. Le pipeline ressemble maintenant à ceci :  <img src="short-circuit.png" alt="Short-circuited pipeline"></p>
<h2 id="faire-des-branches-dans-le-pipeline">Faire des branches dans le pipeline</h2>
<p>Dans les exemples précédents, il y avait une seule &ldquo;branche&rdquo; dans le pipeline : le middleware qui suivait A était toujours B, et le middleware qui suivait B était toujours C. Mais rien n'impose que ça se passe comme ça ; on peut aussi faire qu'une requête donnée soit traitée par un autre pipeline, en fonction du chemin ou de tout autre critère.  Il y a deux types de branches : celles qui rejoignent le pipeline principal, et celles qui s'en séparent définitivement.</p>
<h3 id="faire-une-branche-entirement-spare">Faire une branche entièrement séparée</h3>
<p>On peut faire cela à l'aide de la méthode <code>Map</code> ou <code>MapWhen</code>. <code>Map</code> permet de spécifier une branche en fonction du chemin de la requête. <code>MapWhen</code> donne un contrôle plus fin : on peut spécifier un prédicat pour décider de passer ou non sur la branche. Prenons un exemple simple avec <code>Map</code> :</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> Configure(IApplicationBuilder app)
{
    app.Use(<span style="color:#66d9ef">async</span> (context, next) =&gt;
    {
        Console.WriteLine(<span style="color:#e6db74">&#34;A (before)&#34;</span>);
        <span style="color:#66d9ef">await</span> next();
        Console.WriteLine(<span style="color:#e6db74">&#34;A (after)&#34;</span>);
    });

    app.Map(
        <span style="color:#66d9ef">new</span> PathString(<span style="color:#e6db74">&#34;/foo&#34;</span>),
        a =&gt; a.Use(<span style="color:#66d9ef">async</span> (context, next) =&gt;
        {
            Console.WriteLine(<span style="color:#e6db74">&#34;B (before)&#34;</span>);
            <span style="color:#66d9ef">await</span> next();
            Console.WriteLine(<span style="color:#e6db74">&#34;B (after)&#34;</span>);
        }));

    app.Run(<span style="color:#66d9ef">async</span> context =&gt;
    {
        Console.WriteLine(<span style="color:#e6db74">&#34;C&#34;</span>);
        <span style="color:#66d9ef">await</span> context.Response.WriteAsync(<span style="color:#e6db74">&#34;Hello world&#34;</span>);
    });
}
</code></pre></div><p>Le premier argument de <code>Map</code> est un <code>PathString</code> qui représente le préfixe du chemin de la requête. Le second argument est un delegate qui configure le pipeline pour la branche (le paramètre <code>a</code> représente le <code>IApplicationBuilder</code> pour la branche). La branche définie par le delegate traitera la requête si son chemin commence par le préfixe spécifié.  Pour une requête qui ne commence pas par <code>/foo</code>, ce code produit la sortie suivante :</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">A (before)
C
A (after)
</code></pre></div><p>Le middleware B n'est pas appelé, puisqu'il est dans la branche, et que la requête ne correspond pas au préfixe pour la branche. Mais pour une requête dont le chemin commence par <code>/foo</code>, la sortie est la suivante :</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">A (before)
B (before)
B (after)
A (after)
</code></pre></div><p>Remarquez que cette requête renvoie une erreur 404 (Not found) : c'est parce que le middleware B appelle <code>next()</code>, mais il n'y a pas de middleware suivant ; dans ce cas le comportement par défaut est de renvoyer une erreur 404. Pour régler ça, on pourrait utiliser <code>Run</code> au lieu de <code>Use</code>, ou alors ne pas appeler <code>next()</code>.  Le pipeline défini par ce code peut être représenté comme suit :  <img src="non-rejoining.png" alt="Non-rejoining branch">  (Pour plus de clarté, j'ai omis les flèches des réponses)  Comme vous pouvez le voir, la branche où se trouve le middleware B ne rejoint pas le pipeline principal, le middleware C n'est donc pas appelé.</p>
<h3 id="faire-une-branche-qui-rejoint-le-pipeline-principal">Faire une branche qui rejoint le pipeline principal</h3>
<p>On peut créer une branche qui rejoint le pipeline principal à l'aide de la méthode <code>UseWhen</code>. Cette méthode accepte un prédicat sur le <code>HttpContext</code> pour décider de passer ou non sur la branche. À la fin de son exécution, cette branche rejoindra le pipeline principal là où elle l'a quitté. Voici un exemple similaire au précédent, mais avec une branche qui rejoint le pipeline principal :</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> Configure(IApplicationBuilder app)
{
    app.Use(<span style="color:#66d9ef">async</span> (context, next) =&gt;
    {
        Console.WriteLine(<span style="color:#e6db74">&#34;A (before)&#34;</span>);
        <span style="color:#66d9ef">await</span> next();
        Console.WriteLine(<span style="color:#e6db74">&#34;A (after)&#34;</span>);
    });

    app.UseWhen(
        context =&gt; context.Request.Path.StartsWithSegments(<span style="color:#66d9ef">new</span> PathString(<span style="color:#e6db74">&#34;/foo&#34;</span>)),
        a =&gt; a.Use(<span style="color:#66d9ef">async</span> (context, next) =&gt;
        {
            Console.WriteLine(<span style="color:#e6db74">&#34;B (before)&#34;</span>);
            <span style="color:#66d9ef">await</span> next();
            Console.WriteLine(<span style="color:#e6db74">&#34;B (after)&#34;</span>);
        }));

    app.Run(<span style="color:#66d9ef">async</span> context =&gt;
    {
        Console.WriteLine(<span style="color:#e6db74">&#34;C&#34;</span>);
        <span style="color:#66d9ef">await</span> context.Response.WriteAsync(<span style="color:#e6db74">&#34;Hello world&#34;</span>);
    });
}
</code></pre></div><p>Pour une requête dont le chemin ne commence pas par <code>/foo</code>, ce code produit la même sortie que l'exemple précédent :</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">A (before)
C
A (after)
</code></pre></div><p>Là encore, le middleware B n'est pas appelé, puisque la requête ne correspond pas au prédicat de la branche. Mais pour une requête dont le chemin commence par <code>/foo</code>, on obtient la sortie suivante :</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">A (before)
B (before)
C
B (after)
A (after)
</code></pre></div><p>Comme on peut le voir, la requête passe par la branche (middleware B), puis revient sur le pipeline principal, en finissant par le middleware C. Le pipeline peut donc être représenté comme suit :  <img src="rejoining.png" alt="Rejoining branch">  Remarquez qu'il n'y a pas de méthode <code>Use</code> qui accepte un <code>PathString</code> pour spécifier le préfixe du chemin. Je ne sais pas pourquoi cette méthode n'est pas incluse, mais il est facile de l'écrire à l'aide de <code>UseWhen</code> :</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> IApplicationBuilder Use(<span style="color:#66d9ef">this</span> IApplicationBuilder builder, PathString pathMatch, Action&lt;IApplicationBuilder&gt; configuration)
{
    <span style="color:#66d9ef">return</span> builder.UseWhen(
        context =&gt; context.Request.Path.StartsWithSegments(pathMatch),
        configuration);
}
</code></pre></div><h2 id="conclusion">Conclusion</h2>
<p>Comme vous pouvez le voir, le principe du pipeline de middlewares est assez simple, mais très puissant. La plupart des fonctionnalités standard d'ASP.NET Core (authentification, fichiers statiques, mise en cache, MVC, etc) sont implémentées comme des middlewares. Et bien sûr, il est très simple de créer son propre middleware !</p>

		</div>
		<footer class="post__footer">
			
<div class="post__tags tags clearfix">
	<svg class="tags__badge icon icon-tag" width="16" height="16" viewBox="0 0 32 32"><path d="M32 19c0 1-1 2-1 2L21 31s-1 1-2 1-2-1-2-1L2 16c-1-1-1.4-2-1.4-2S0 12.5 0 11V3C0 1.5.8.8.8.8S1.5 0 3 0h8c1.5 0 3 .6 3 .6S15 1 16 2l15 15s1 1 1 2zM7 10a3 3 0 1 0 0-6 3 3 0 0 0 0 6z"/></svg>
	<ul class="tags__list">
		<li class="tags__item">
			<a class="tags__link btn" href="/tags/.net-core/" rel="tag">.net core</a>
		</li>
		<li class="tags__item">
			<a class="tags__link btn" href="/tags/asp.net/" rel="tag">asp.net</a>
		</li>
		<li class="tags__item">
			<a class="tags__link btn" href="/tags/asp.net-core/" rel="tag">asp.net core</a>
		</li>
		<li class="tags__item">
			<a class="tags__link btn" href="/tags/c%23/" rel="tag">C#</a>
		</li>
		<li class="tags__item">
			<a class="tags__link btn" href="/tags/middleware/" rel="tag">middleware</a>
		</li>
		<li class="tags__item">
			<a class="tags__link btn" href="/tags/pipeline/" rel="tag">pipeline</a>
		</li>
	</ul>
</div>
		</footer>
	</article>
</main>

<div class="authorbox clearfix">
	<figure class="authorbox__avatar">
		<img alt="Thomas Levesque avatar" src="/images/avatar.jpg" class="avatar" height="90" width="90">
	</figure>
	<div class="authorbox__header">
		<span class="authorbox__name">À propos Thomas Levesque</span>
	</div>
	<div class="authorbox__description">
		Thomas Levesque est un développeur français vivant à Paris.
	</div>
</div>

<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/2018/03/06/nettoyer-lhistorique-dune-branche-git-pour-supprimer-les-fichiers-indesirables/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Précédent</span>
			<p class="pager__title">Nettoyer l&#39;historique d&#39;une branche Git pour supprimer les fichiers indésirables</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/2018/04/17/fin-de-mon-blog-en-francais/" rel="next">
			<span class="pager__subtitle">Suivant&thinsp;»</span>
			<p class="pager__title">Fin de mon blog en français</p>
		</a>
	</div>
</nav>

<div>
    <script src="https://utteranc.es/client.js"
            repo="thomaslevesque/blog-fr"
            issue-term="pathname"
            label="post-comment"
            theme="github-light"
            crossorigin="anonymous"
            async>
    </script>
</div>


			</div>
			<aside class="sidebar"><div class="widget-search widget">
	<form class="widget-search__form" role="search" method="get" action="https://google.com/search">
		<label>
			<input class="widget-search__field" type="search" placeholder="Rechercher..." value="" name="q" aria-label="Rechercher...">
		</label>
		<input class="widget-search__submit" type="submit" value="Search">
		<input type="hidden" name="sitesearch" value="https://thomaslevesque.fr/" />
	</form>
</div>
<div class="widget-social widget">
    <h4 class="widget-social__title widget__title">Social</h4>
    <div class="widget-social__content widget__content">
        <a class="widget-social__link-custom widget__link" title="GitHub" rel="noopener noreferrer" href="https://github.com/thomaslevesque" target="_blank">
            <svg class="widget-social__link-icon-custom icon icon-github" width="24" height="24" viewBox="0 0 384 374"><path d="m192 0c-106.1 0-192 85.8-192 191.7 0 84.7 55 156.6 131.3 181.9 9.6 1.8 13.1-4.2 13.1-9.2 0-4.6-.2-16.6-.3-32.6-53.4 11.6-64.7-25.7-64.7-25.7-8.7-22.1-21.3-28-21.3-28-17.4-11.9 1.3-11.6 1.3-11.6 19.3 1.4 29.4 19.8 29.4 19.8 17.1 29.3 44.9 20.8 55.9 15.9 1.7-12.4 6.7-20.8 12.2-25.6-42.6-4.8-87.5-21.3-87.5-94.8 0-20.9 7.5-38 19.8-51.4-2-4.9-8.6-24.3 1.9-50.7 0 0 16.1-5.2 52.8 19.7 15.3-4.2 31.7-6.4 48.1-6.5 16.3.1 32.7 2.2 48.1 6.5 36.7-24.8 52.8-19.7 52.8-19.7 10.5 26.4 3.9 45.9 1.9 50.7 12.3 13.4 19.7 30.5 19.7 51.4 0 73.7-44.9 89.9-87.7 94.6 6.9 5.9 13 17.6 13 35.5 0 25.6-.2 46.3-.2 52.6 0 5.1 3.5 11.1 13.2 9.2 76.2-25.5 131.2-97.3 131.2-182 0-105.9-86-191.7-192-191.7z"/></svg>
        </a>
        <a class="widget-social__link-custom widget__link" title="Twitter" rel="noopener noreferrer" href="https://twitter.com/thomaslevesque" target="_blank">
            <svg class="widget-social__link-icon-custom icon icon-twitter" width="24" height="24" viewBox="0 0 384 312"><path d="m384 36.9c-14.1 6.3-29.3 10.5-45.2 12.4 16.3-9.7 28.8-25.2 34.6-43.6-15.2 9-32.1 15.6-50 19.1-14.4-15.2-34.9-24.8-57.5-24.8-43.5 0-78.8 35.3-78.8 78.8 0 6.2.7 12.2 2 17.9-65.5-3.3-123.5-34.6-162.4-82.3-6.7 11.6-10.6 25.2-10.6 39.6 0 27.3 13.9 51.4 35 65.6-12.9-.4-25.1-4-35.7-9.9v1c0 38.2 27.2 70 63.2 77.2-6.6 1.8-13.6 2.8-20.8 2.8-5.1 0-10-.5-14.8-1.4 10 31.3 39.1 54.1 73.6 54.7-27 21.1-60.9 33.7-97.8 33.7-6.4 0-12.6-.4-18.8-1.1 34.9 22.4 76.3 35.4 120.8 35.4 144.9 0 224.1-120 224.1-224.1 0-3.4-.1-6.8-.2-10.2 15.4-11.1 28.7-25 39.3-40.8z"/></svg>
        </a>
    </div>
</div>
<div class="widget-recent widget">
	<h4 class="widget__title">Articles récents</h4>
	<div class="widget__content">
		<ul class="widget__list">
			<li class="widget__item"><a class="widget__link" href="/2018/04/17/fin-de-mon-blog-en-francais/">Fin de mon blog en français</a></li>
			<li class="widget__item"><a class="widget__link" href="/2018/03/27/comprendre-le-pipeline-de-middleware-dasp-net-core/">Comprendre le pipeline de middleware d&#39;ASP.NET Core</a></li>
			<li class="widget__item"><a class="widget__link" href="/2018/03/06/nettoyer-lhistorique-dune-branche-git-pour-supprimer-les-fichiers-indesirables/">Nettoyer l&#39;historique d&#39;une branche Git pour supprimer les fichiers indésirables</a></li>
			<li class="widget__item"><a class="widget__link" href="/2018/02/25/meilleure-gestion-du-timeout-avec-httpclient/">Meilleure gestion du timeout avec HttpClient</a></li>
			<li class="widget__item"><a class="widget__link" href="/2017/11/14/transformer-les-templates-t4-pendant-la-build-et-passer-des-variables-du-projet/">Transformer les templates T4 pendant la build, et passer des variables du projet</a></li>
		</ul>
	</div>
</div>
<div class="widget-taglist widget">
	<h4 class="widget__title">Mots-clefs</h4>
	<div class="widget__content">
		<a class="widget-taglist__link widget__link btn" href="/tags/c%23/" title="c#">c#</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/wpf/" title="wpf">wpf</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/xaml/" title="xaml">xaml</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/visual-studio/" title="visual-studio">visual-studio</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/async/" title="async">async</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/binding/" title="binding">binding</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/markup-extension/" title="markup-extension">markup-extension</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/mvvm/" title="mvvm">mvvm</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/linq/" title="linq">linq</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/tests-unitaires/" title="tests-unitaires">tests-unitaires</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/winrt/" title="winrt">winrt</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/.net/" title=".net">.net</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/.net-4.0/" title=".net-4.0">.net-4.0</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/.net-core/" title=".net-core">.net-core</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/asynchrone/" title="asynchrone">asynchrone</a>
	</div>
</div>
</aside>
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2020 Thomas Levesque.
			<span class="footer__copyright-credits">Produit par <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> et le thème <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a>.</span>
		</div>
	</div>
</footer>
	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>