<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Uncategorized on Blog .NET de Thomas Levesque</title>
    <link>https://thomaslevesque.fr/categories/uncategorized/</link>
    <description>Recent content in Uncategorized on Blog .NET de Thomas Levesque</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>fr-fr</language>
    <lastBuildDate>Tue, 17 Apr 2018 00:00:00 +0000</lastBuildDate><atom:link href="https://thomaslevesque.fr/categories/uncategorized/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Fin de mon blog en français</title>
      <link>https://thomaslevesque.fr/2018/04/17/fin-de-mon-blog-en-francais/</link>
      <pubDate>Tue, 17 Apr 2018 00:00:00 +0000</pubDate>
      
      <guid>https://thomaslevesque.fr/2018/04/17/fin-de-mon-blog-en-francais/</guid>
      <description>Chers lecteurs, J&amp;rsquo;ai créé ce blog en français il y a 10 ans environ. Quelque temps plus tard, j&amp;rsquo;en ai créé une version anglaise pour toucher une plus large audience. Pendant des années, j&amp;rsquo;ai publié tous mes articles dans les deux langues. Mais l&amp;rsquo;audience de la version française n&amp;rsquo;a jamais vraiment décollé, et le fait de devoir traduire tous mes articles nuit à ma motivation pour écrire. J&amp;rsquo;ai donc décidé d&amp;rsquo;arrêter pour consacrer mon énergie à la version anglaise, qui est lue par beaucoup plus de monde (environ 20 fois plus).</description>
    </item>
    
    <item>
      <title>Comprendre le pipeline de middleware d&#39;ASP.NET Core</title>
      <link>https://thomaslevesque.fr/2018/03/27/comprendre-le-pipeline-de-middleware-dasp-net-core/</link>
      <pubDate>Tue, 27 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://thomaslevesque.fr/2018/03/27/comprendre-le-pipeline-de-middleware-dasp-net-core/</guid>
      <description>Middlewhat? L&amp;rsquo;architecture d&amp;rsquo;ASP.NET Core est basée sur un système de middlewares, des morceaux de code qui gèrent les requêtes et réponses. Les middlewares sont chainés les uns aux autres pour constituer un pipeline. Les requêtes entrantes passent dans le pipeline, où chaque middleware a l&amp;rsquo;occasion de les examiner et/ou de les modifier avant des les passer au middleware suivant. Les réponses sortantes passent aussi dans le pipeline, dans l&amp;rsquo;ordre inverse. Si tout cela semble très abstrait, le schéma suivant, tiré de la documentation officielle ASP.</description>
    </item>
    
    <item>
      <title>Nettoyer l&#39;historique d&#39;une branche Git pour supprimer les fichiers indésirables</title>
      <link>https://thomaslevesque.fr/2018/03/06/nettoyer-lhistorique-dune-branche-git-pour-supprimer-les-fichiers-indesirables/</link>
      <pubDate>Tue, 06 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://thomaslevesque.fr/2018/03/06/nettoyer-lhistorique-dune-branche-git-pour-supprimer-les-fichiers-indesirables/</guid>
      <description>J&amp;rsquo;ai récemment eu à travailler sur un dépôt Git qui contenait des modifications à reporter sur un autre dépôt. Malheureusement, ce dépôt n&amp;rsquo;avait pas de fichier .gitignore au départ, si bien que de nombreux fichiers inutiles (répertoires bin/obj/packages&amp;hellip;) avaient été archivés. Cela rendait l&amp;rsquo;historique très difficile à lire, puisque chaque commit contenait des centaines de fichiers modifiés.
Heureusement, Git permet assez facilement de &amp;ldquo;nettoyer&amp;rdquo; une branche, en recréant les mêmes commits sans les fichiers qui n&amp;rsquo;auraient pas dû se trouver là.</description>
    </item>
    
    <item>
      <title>Meilleure gestion du timeout avec HttpClient</title>
      <link>https://thomaslevesque.fr/2018/02/25/meilleure-gestion-du-timeout-avec-httpclient/</link>
      <pubDate>Sun, 25 Feb 2018 00:00:00 +0000</pubDate>
      
      <guid>https://thomaslevesque.fr/2018/02/25/meilleure-gestion-du-timeout-avec-httpclient/</guid>
      <description>Le problème Si vous avez l&amp;rsquo;habitude d&amp;rsquo;utiliser HttpClient pour appeler des APIs REST ou transférer des fichiers, vous avez peut-être déjà pesté contre la façon dont cette classe gère le timeout. Il y a en effet deux problèmes majeurs dans la gestion du timeout par HttpClient :
 Le timeout est défini de façon globale, et s&amp;rsquo;applique à toutes les requêtes, alors qu&amp;rsquo;il serait plus pratique de pouvoir le définir individuellement pour chaque requête.</description>
    </item>
    
    <item>
      <title>Transformer les templates T4 pendant la build, et passer des variables du projet</title>
      <link>https://thomaslevesque.fr/2017/11/14/transformer-les-templates-t4-pendant-la-build-et-passer-des-variables-du-projet/</link>
      <pubDate>Tue, 14 Nov 2017 00:00:00 +0000</pubDate>
      
      <guid>https://thomaslevesque.fr/2017/11/14/transformer-les-templates-t4-pendant-la-build-et-passer-des-variables-du-projet/</guid>
      <description>T4 (Text Template Transformation Toolkit) est un excellent outil pour générer du code ; on peut, par exemple, créer des classes POCO à partir des tables d&amp;rsquo;une base de données, générer du code répétitif, etc. Dans Visual Studio, les fichiers T4 (extension .tt) sont associés au custom tool TextTemplatingFileGenerator, qui transforme un template pour générer un fichier de sortie à chaque fois qu&amp;rsquo;on enregistre le template. Mais il arrive que ce ne soit pas suffisant, et qu&amp;rsquo;on souhaite regénérer les sorties des templates à chaque build.</description>
    </item>
    
    <item>
      <title>Propriétés et éléments MSBuild partagés avec Directory.Build.props</title>
      <link>https://thomaslevesque.fr/2017/09/20/proprietes-et-elements-msbuild-partages-avec-directory-build-props/</link>
      <pubDate>Wed, 20 Sep 2017 00:00:00 +0000</pubDate>
      
      <guid>https://thomaslevesque.fr/2017/09/20/proprietes-et-elements-msbuild-partages-avec-directory-build-props/</guid>
      <description>Pour être honnête, je n&amp;rsquo;ai jamais vraiment aimé MSBuild jusqu&amp;rsquo;à récemment. Les fichiers de projet générés par Visual Studio étaient immondes, l&amp;rsquo;essentiel de leur contenu était redondant, il fallait décharger les projets pour les éditer, c&amp;rsquo;était mal documenté&amp;hellip; Mais avec l&amp;rsquo;avènement de .NET Core et du nouveau format de projet, plus léger, MSBuild est devenu un bien meilleur outil.
MSBuild 15 a introduit une nouvelle fonctionnalité assez sympa : les imports implicites (je ne sais pas si c&amp;rsquo;est le nom officiel, mais c&amp;rsquo;est celui que j&amp;rsquo;utiliserai).</description>
    </item>
    
    <item>
      <title>Amélioration des performances de Linq dans .NET Core</title>
      <link>https://thomaslevesque.fr/2017/04/01/amelioration-des-performances-de-linq-dans-net-core/</link>
      <pubDate>Sat, 01 Apr 2017 00:00:00 +0000</pubDate>
      
      <guid>https://thomaslevesque.fr/2017/04/01/amelioration-des-performances-de-linq-dans-net-core/</guid>
      <description>Depuis le temps qu&amp;rsquo;on en parle, vous êtes sans doute au courant que Microsoft a publié une version open-source et multiplateforme de .NET : .NET Core. Cela signifie que vous pouvez maintenant créer et exécuter des applications .NET sous Linux ou macOS. C&amp;rsquo;est déjà assez cool en soi, mais ça ne s&amp;rsquo;arrête pas là : .NET Core apporte aussi beaucoup d&amp;rsquo;améliorations à la Base Class Library.
Par exemple, Linq est plus rapide dans .</description>
    </item>
    
    <item>
      <title>Parser du texte facilement en C# avec Sprache</title>
      <link>https://thomaslevesque.fr/2017/02/28/parser-du-texte-facilement-en-c-avec-sprache/</link>
      <pubDate>Tue, 28 Feb 2017 00:00:00 +0000</pubDate>
      
      <guid>https://thomaslevesque.fr/2017/02/28/parser-du-texte-facilement-en-c-avec-sprache/</guid>
      <description>Il y a quelques jours, j&amp;rsquo;ai découvert un petit bijou : Sprache. Le nom signifie &amp;ldquo;langage&amp;rdquo; en allemand. C&amp;rsquo;est une librairie très élégante et facile à utiliser pour créer des analyseurs de texte, à l&amp;rsquo;aide de parser combinators, qui sont une technique très courante en programmation fonctionnelle. Le concept théorique peut sembler un peu effrayant, mais comme vous allez le voir dans un instant, Sprache rend ça très accessible.
Analyse syntaxique L&amp;rsquo;analyse syntaxique (parsing) est une tâche très courante, mais qui peut être laborieuse et où il est facile de faire des erreurs.</description>
    </item>
    
    <item>
      <title>Quoi de neuf dans FakeItEasy 3.0.0 ?</title>
      <link>https://thomaslevesque.fr/2017/02/26/quoi-de-neuf-dans-fakeiteasy-3-0-0/</link>
      <pubDate>Sun, 26 Feb 2017 00:00:00 +0000</pubDate>
      
      <guid>https://thomaslevesque.fr/2017/02/26/quoi-de-neuf-dans-fakeiteasy-3-0-0/</guid>
      <description>FakeItEasy est un framework de mocking populaire pour .NET, avec une API intuitive et facile à utiliser. Depuis environ un an, je suis un des principaux développeurs de FakeItEasy, avec Adam Ralph and Blair Conrad. Ça a été un vrai plaisir de travailler avec eux, et je me suis éclaté !
Aujourd&amp;rsquo;hui j&amp;rsquo;ai le plaisir d&amp;rsquo;annoncer la sortie de FakeItEasy 3.0.0, avec le support de .NET Core et quelques fonctionnalités utiles.</description>
    </item>
    
    <item>
      <title>Méthodes C# dans les en-têtes de diff git</title>
      <link>https://thomaslevesque.fr/2017/02/10/methodes-c-dans-les-en-tetes-de-diff-git/</link>
      <pubDate>Fri, 10 Feb 2017 00:00:00 +0000</pubDate>
      
      <guid>https://thomaslevesque.fr/2017/02/10/methodes-c-dans-les-en-tetes-de-diff-git/</guid>
      <description>Si vous utilisez git en ligne de commande, vous aurez peut-être remarqué que les diffs indiquent souvent la signature de la méthode dans l&amp;rsquo;en-tête du bloc (la ligne qui commence par @@), comme ceci :
diff --git a/Program.cs b/Program.cs index 655a213..5ae1016 100644 --- a/Program.cs +++ b/Program.cs @@ -13,6 +13,7 @@ static void Main(string[] args)  Console.WriteLine(&amp;#34;Hello World!&amp;#34;);  Console.WriteLine(&amp;#34;Hello World!&amp;#34;);  Console.WriteLine(&amp;#34;Hello World!&amp;#34;); + Console.WriteLine(&amp;#34;blah&amp;#34;);  } C&amp;rsquo;est très pratique pour savoir où vous vous trouvez quand vous regardez un diff.</description>
    </item>
    
    <item>
      <title>Tout faire ou presque avec le pipeline de HttpClient</title>
      <link>https://thomaslevesque.fr/2016/12/11/tout-faire-ou-presque-avec-le-pipeline-de-httpclient/</link>
      <pubDate>Sun, 11 Dec 2016 00:00:00 +0000</pubDate>
      
      <guid>https://thomaslevesque.fr/2016/12/11/tout-faire-ou-presque-avec-le-pipeline-de-httpclient/</guid>
      <description>Il y a quelques années, Microsoft a introduit la classe HttpClient comme alternative moderne à HttpWebRequest pour faire des requêtes web depuis des applications .NET. Non seulement cette nouvelle API est beaucoup plus facile à utiliser, plus propre, et asynchrone, mais elle est aussi facilement extensible.
Vous avez peut-être remarqué que HttpClient a un constructeur qui accepte un HttpMessageHandler. De quoi s&amp;rsquo;agit-il ? Un HttpMessageHandler est un objet qui accepte une requête (HttpRequestMessage) et renvoie une réponse (HttpResponseMessage) ; la façon dont il le fait dépend complètement de l&amp;rsquo;implémentation.</description>
    </item>
    
    <item>
      <title>Déconstruction de tuples en C# 7</title>
      <link>https://thomaslevesque.fr/2016/08/23/deconstruction-de-tuples-en-c-7/</link>
      <pubDate>Tue, 23 Aug 2016 00:00:00 +0000</pubDate>
      
      <guid>https://thomaslevesque.fr/2016/08/23/deconstruction-de-tuples-en-c-7/</guid>
      <description>Dans mon précedent billet, j&amp;rsquo;ai parlé d&amp;rsquo;une nouvelle fonctionnalité de C# 7 : les tuples. Dans Visual Studio 15 Preview 3, cette feature n&amp;rsquo;était pas tout à fait terminée ; il lui manquait 2 aspects importants :
 la génération de métadonnées pour les noms des éléments des tuples, pour que les noms soient préservés entre les assemblies la déconstruction des tuples en variables distinctes  Eh bien, il semble que l&amp;rsquo;équipe du langage C# n&amp;rsquo;a pas chômé au cours du mois écoulé, car ces deux éléments sont maintenant implémentés dans VS 15 Preview 4, qui a été publié hier !</description>
    </item>
    
    <item>
      <title>Tuples en C# 7</title>
      <link>https://thomaslevesque.fr/2016/07/28/tuples-en-c-7/</link>
      <pubDate>Thu, 28 Jul 2016 00:00:00 +0000</pubDate>
      
      <guid>https://thomaslevesque.fr/2016/07/28/tuples-en-c-7/</guid>
      <description>Un tuple est une liste finie et ordonnée de valeurs, éventuellement de types différents, et est utilisé pour regrouper des valeurs liées entre elles sans avoir à créer une type spécifique pour les contenir.
.NET 4.0 a introduit un ensemble de classes Tuple , qui s’utilisent de la façon suivante
private static Tuple&amp;lt;int, double&amp;gt; Tally(IEnumerable&amp;lt;double&amp;gt; values) {  int count = 0;  double sum = 0.0;  foreach (var value in values)  {  count++;  sum += value;  }  return Tuple.</description>
    </item>
    
    <item>
      <title>Piège: utiliser var et async ensemble</title>
      <link>https://thomaslevesque.fr/2016/06/24/piege-utiliser-var-et-async-ensemble/</link>
      <pubDate>Fri, 24 Jun 2016 00:00:00 +0000</pubDate>
      
      <guid>https://thomaslevesque.fr/2016/06/24/piege-utiliser-var-et-async-ensemble/</guid>
      <description>Il y a quelques jours au bureau, je suis tombé sur un bug assez sournois dans notre application principale. Le code semblait assez innocent, et à première vue je ne voyais vraiment pas ce qui n’allait pas… Le code était similaire à ceci:
public async Task&amp;lt;bool&amp;gt; BookExistsAsync(int id) {  var store = await GetBookStoreAsync();  var book = store.GetBookByIdAsync(id);  return book != null; }  // Pour donner le contexte, voici les types et méthodes utilisés dans BookExistsAsync:  private Task&amp;lt;IBookStore&amp;gt; GetBookStoreAsync() {  // .</description>
    </item>
    
    <item>
      <title>Publier un package sur NuGet.org depuis AppVeyor</title>
      <link>https://thomaslevesque.fr/2016/04/26/publier-un-package-sur-nuget-org-depuis-appveyor/</link>
      <pubDate>Tue, 26 Apr 2016 00:00:00 +0000</pubDate>
      
      <guid>https://thomaslevesque.fr/2016/04/26/publier-un-package-sur-nuget-org-depuis-appveyor/</guid>
      <description>Depuis quelques mois, j’utilise AppVeyor CI pour certains de mes projets open-source (avec Cake pour les scripts de build). J’en suis très content, mais il y avait un point qui m’ennuyait : je ne trouvais pas comment publier des packages sur NuGet.org directement depuis AppVeyor. Il fallait que je télécharge le package en local, puis que je l’uploade manuellement depuis ma machine (soit avec nuget push en ligne de commande, soit via le formulaire web sur NuGet.</description>
    </item>
    
    <item>
      <title>Essai des fonctionnalités de C# 7 dans Visual Studio “15” Preview</title>
      <link>https://thomaslevesque.fr/2016/04/17/essai-des-fonctionnalits-de-c-7-dans-visual-studio-15-preview/</link>
      <pubDate>Sun, 17 Apr 2016 00:00:00 +0000</pubDate>
      
      <guid>https://thomaslevesque.fr/2016/04/17/essai-des-fonctionnalits-de-c-7-dans-visual-studio-15-preview/</guid>
      <description>Il y a environ deux semaines, Microsoft a publié la première version préliminaire de la prochaine mouture de Visual Studio. Vous pourrez découvrir toutes les nouveautés qu’elle contient dans les notes de version. Il y a quelques nouveautés vraiment sympa (j’aime particulièrement le nouvel “installeur léger”), mais le plus intéressant pour moi est que le compilateur C# livré avec inclut quelques unes des fonctionnalités prévues pour C# 7. Regardons ça de plus près !</description>
    </item>
    
    <item>
      <title>Utiliser plusieurs sources d’annulation avec CreateLinkedTokenSource</title>
      <link>https://thomaslevesque.fr/2015/12/31/utiliser-plusieurs-sources-dannulation-avec-createlinkedtokensource/</link>
      <pubDate>Thu, 31 Dec 2015 00:00:00 +0000</pubDate>
      
      <guid>https://thomaslevesque.fr/2015/12/31/utiliser-plusieurs-sources-dannulation-avec-createlinkedtokensource/</guid>
      <description>La programmation asynchrone en C# était auparavant quelque chose de difficile ; grâce à la Task Parallel Library de .NET 4 et au async/await de C# 5, elle est devenu relativement facile, et en conséquence, est de plus en plus couramment utilisée. Dans le même temps, une approche standardisée pour gérer l’annulation a été introduite : les jetons d’annulation. L’idée générale est que vous créez un CancellationTokenSource qui contrôle l’annulation, et vous passez le jeton qu’il fournit à la méthode que vous voulez pouvoir annuler.</description>
    </item>
    
    <item>
      <title>Filtres d’exception en C# 6 : leur plus grand avantage n’est pas celui qu’on croit</title>
      <link>https://thomaslevesque.fr/2015/06/23/filtres-dexception-en-c-6-leur-plus-grand-avantage-nest-pas-celui-quon-croit/</link>
      <pubDate>Tue, 23 Jun 2015 00:00:00 +0000</pubDate>
      
      <guid>https://thomaslevesque.fr/2015/06/23/filtres-dexception-en-c-6-leur-plus-grand-avantage-nest-pas-celui-quon-croit/</guid>
      <description>Les filtres d’exception sont l’une des fonctionnalités majeures de C# 6. Ils tirent parti d’une fonctionnalité du CLR qui a toujours existé, mais qui n’était pas exploitée en C# jusqu’ici. Ils permettent de spécifier une condition sur un bloc catch :
static void Main() { try { Foo.DoSomethingThatMightFail(null); } catch (MyException ex) when (ex.Code == 42) { Console.WriteLine(&amp;#34;Error 42 occurred&amp;#34;); } } Comme on pourrait s’y attendre, le bloc catch ne sera exécuté que si ex.</description>
    </item>
    
    <item>
      <title>Personnaliser l’interpolation de chaine avec C# 6</title>
      <link>https://thomaslevesque.fr/2015/02/25/personnaliser-linterpolation-de-chaine-avec-c-6/</link>
      <pubDate>Wed, 25 Feb 2015 00:00:00 +0000</pubDate>
      
      <guid>https://thomaslevesque.fr/2015/02/25/personnaliser-linterpolation-de-chaine-avec-c-6/</guid>
      <description>L’une des principales nouveautés de C# 6 est l’interpolation de chaines de caractères, qui permet d’écrire ce genre de chose :
string text = $&amp;#34;{p.Name} was born on {p.DateOfBirth:D}&amp;#34;; Un aspect peu connu de cette fonctionnalité est qu’une chaine interpolée peut être traitée soit comme un String, soit comme un IFormattable, selon le contexte. Quand elle est convertie en IFormattable, cela crée un objet FormattableString qui implémente l’interface et expose :</description>
    </item>
    
    <item>
      <title>Optimiser ToArray et ToList en fournissant le nombre d’éléments</title>
      <link>https://thomaslevesque.fr/2014/12/08/optimiser-toarray-et-tolist-en-fournissant-le-nombre-dlments/</link>
      <pubDate>Mon, 08 Dec 2014 00:00:00 +0000</pubDate>
      
      <guid>https://thomaslevesque.fr/2014/12/08/optimiser-toarray-et-tolist-en-fournissant-le-nombre-dlments/</guid>
      <description>Les méthodes d’extension ToArray et ToList sont des moyens pratiques de matérialiser une séquence énumérable (par exemple une requête Linq). Cependant, quelque chose me chiffonne : ces deux méthodes sont très inefficaces si elles ne connaissent pas le nombre d’éléments dans la séquence (ce qui est presque toujours le cas quand on les utilise sur une requête Linq). Concentrons nous sur ToArray pour l’instant (ToList a quelques différences, mais le principe est essentiellement le même).</description>
    </item>
    
    <item>
      <title>StringTemplate: une autre approche de l’interpolation de chaines</title>
      <link>https://thomaslevesque.fr/2014/11/17/stringtemplate-une-autre-approche-de-l-interpolation-de-chaines/</link>
      <pubDate>Mon, 17 Nov 2014 00:00:00 +0000</pubDate>
      
      <guid>https://thomaslevesque.fr/2014/11/17/stringtemplate-une-autre-approche-de-l-interpolation-de-chaines/</guid>
      <description>Avec la version 6 de C# qui approche, il y a beaucoup de discussions sur CodePlex et ailleurs à propos de l’interpolation de chaines. Pas très étonnant, puisqu’il s’agit d’une des fonctionnalités majeures de cette version… Au cas où vous auriez vécu dans une grotte ces derniers mois et n’en auriez pas entendu parler, l’interpolation de chaines est un moyen d’insérer des expressions C# à l’intérieur d’une chaine de caractère, de façon à ce qu’elles soient évaluées lors de l’exécution et remplacées par leurs valeurs.</description>
    </item>
    
    <item>
      <title>Un moyen facile de tester unitairement la validation des arguments null</title>
      <link>https://thomaslevesque.fr/2014/11/02/easy-unit-testing-of-null-argument-validation/</link>
      <pubDate>Sun, 02 Nov 2014 00:00:00 +0000</pubDate>
      
      <guid>https://thomaslevesque.fr/2014/11/02/easy-unit-testing-of-null-argument-validation/</guid>
      <description>Quand on teste unitairement une méthode, une des choses à tester est la validation des arguments : par exemple, vérifier que la méthode lève bien une ArgumentNullException quand un argument null est passé pour un paramètre qui ne doit pas être null. Ecrire ce genre de test est très facile, mais c’est une tâche fastidieuse et répétitive, surtout pour une méthode qui a beaucoup de paramètres. J’ai donc écrit une méthode qui automatise en partie cette tâche : elle essaie de passer null pour chacun des arguments spécifiés, et vérifie que la méthode lève bien une ArgumentNullException.</description>
    </item>
    
    <item>
      <title>Envoyer des données avec HttpClient selon un modèle “push”</title>
      <link>https://thomaslevesque.fr/2013/12/01/envoyer-des-donnees-avec-httpclient-selon-un-modele-push/</link>
      <pubDate>Sun, 01 Dec 2013 00:00:00 +0000</pubDate>
      
      <guid>https://thomaslevesque.fr/2013/12/01/envoyer-des-donnees-avec-httpclient-selon-un-modele-push/</guid>
      <description>Si vous avez déjà utilisé la classe HttpWebRequest pour envoyer des données, vous savez qu’elle utilise un modèle “push”. Ce que j’entends par là, c’est que vous appelez la méthode GetRequestStream, qui ouvre la connexion si nécessaire, envoie les en-têtes, et renvoie un flux sur lequel vous pouvez écrire directement.
.NET 4.5 a introduit la classe HttpClient comme nouveau moyen de communiquer en HTTP. Elle repose en fait sur HttpWebRequest en interne, mais offre une API plus pratique et complètement asynchrone.</description>
    </item>
    
    <item>
      <title>Les autres nouveautés de Visual Studio 2012</title>
      <link>https://thomaslevesque.fr/2012/06/11/les-autres-nouveautes-de-visual-studio-2012/</link>
      <pubDate>Mon, 11 Jun 2012 00:00:00 +0000</pubDate>
      
      <guid>https://thomaslevesque.fr/2012/06/11/les-autres-nouveautes-de-visual-studio-2012/</guid>
      <description>Visual Studio 2012 RC est sorti il y a 10 jours, et bien que je n’ai pas encore eu beaucoup de temps pour jouer avec, j’en suis assez satisfait pour l’instant. Beaucoup de choses ont déjà été dites sur le design, ainsi que sur les nouvelles fonctionnalités les plus importantes, mais il y a aussi beaucoup de petites améliorations moins remarquables qui vont nous faciliter la vie. Comme je n’ai pas vu grand chose d’écrit à ce sujet, je me suis dit qu’il serait utile de faire une petite liste de ce que j’ai remarqué jusqu’ici.</description>
    </item>
    
  </channel>
</rss>
