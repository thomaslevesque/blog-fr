<!DOCTYPE html>
<html class="no-js" lang="fr">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>Tout faire ou presque avec le pipeline de HttpClient - Blog .NET de Thomas Levesque</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
	<meta property="og:title" content="Tout faire ou presque avec le pipeline de HttpClient" />
<meta property="og:description" content="Il y a quelques années, Microsoft a introduit la classe HttpClient comme alternative moderne à HttpWebRequest pour faire des requêtes web depuis des applications .NET. Non seulement cette nouvelle API est beaucoup plus facile à utiliser, plus propre, et asynchrone, mais elle est aussi facilement extensible.
Vous avez peut-être remarqué que HttpClient a un constructeur qui accepte un HttpMessageHandler. De quoi s&#39;agit-il ? Un HttpMessageHandler est un objet qui accepte une requête (HttpRequestMessage) et renvoie une réponse (HttpResponseMessage) ; la façon dont il le fait dépend complètement de l&#39;implémentation." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://thomaslevesque.fr/2016/12/11/tout-faire-ou-presque-avec-le-pipeline-de-httpclient/" />
<meta property="article:published_time" content="2016-12-11T00:00:00+00:00" />
<meta property="article:modified_time" content="2016-12-11T00:00:00+00:00" />

	<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Tout faire ou presque avec le pipeline de HttpClient"/>
<meta name="twitter:description" content="Il y a quelques années, Microsoft a introduit la classe HttpClient comme alternative moderne à HttpWebRequest pour faire des requêtes web depuis des applications .NET. Non seulement cette nouvelle API est beaucoup plus facile à utiliser, plus propre, et asynchrone, mais elle est aussi facilement extensible.
Vous avez peut-être remarqué que HttpClient a un constructeur qui accepte un HttpMessageHandler. De quoi s&#39;agit-il ? Un HttpMessageHandler est un objet qui accepte une requête (HttpRequestMessage) et renvoie une réponse (HttpResponseMessage) ; la façon dont il le fait dépend complètement de l&#39;implémentation."/>

	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">
	<link rel="stylesheet" href="/css/style.css">
	<link rel="stylesheet" href="/css/social.css">
	<link rel="shortcut icon" href="/favicon.ico">
		
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-31645024-1', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>

</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container">
		<div class="logo">
			<a class="logo__link" href="/" title="Blog .NET de Thomas Levesque" rel="home">
				<div class="logo__title">Blog .NET de Thomas Levesque</div>
				<div class="logo__tagline">Nouveautés, découvertes, réflexions, trucs, astuces en tous genres sur les technologies .NET</div>
			</a>
		</div>
		
<nav class="menu">
	<button class="menu__btn" aria-haspopup="true" aria-expanded="false" tabindex="0">
		<span class="menu__btn-title" tabindex="-1">Menu</span>
	</button>
	<ul class="menu__list">
		<li class="menu__item">
			<a class="menu__link" href="/a-propos/">
				
				<span class="menu__text">À propos</span>
				
			</a>
		</li>
	</ul>
</nav>

	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Tout faire ou presque avec le pipeline de HttpClient</h1>
			<div class="post__meta meta">
<div class="meta__item-datetime meta__item">
	<svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class="meta__text" datetime="2016-12-11T00:00:00Z">December 11, 2016</time></div></div>
		</header><div class="content post__content clearfix">
			<p>Il y a quelques années, Microsoft a introduit la classe <code>HttpClient</code> comme alternative moderne à <code>HttpWebRequest</code> pour faire des requêtes web depuis des applications .NET. Non seulement cette nouvelle API est beaucoup plus facile à utiliser, plus propre, et asynchrone, mais elle est aussi facilement extensible.</p>
<p>Vous avez peut-être remarqué que <code>HttpClient</code> a un constructeur qui accepte un <code>HttpMessageHandler</code>. De quoi s'agit-il ? Un <code>HttpMessageHandler</code> est un objet qui accepte une requête (<code>HttpRequestMessage</code>) et renvoie une réponse (<code>HttpResponseMessage</code>) ; la façon dont il le fait dépend complètement de l'implémentation. Par défaut, <code>HttpClient</code> utilise <code>HttpClientHandler</code>, un handler qui envoie une requête vers un serveur sur le réseau et renvoie la réponse du serveur. L'autre implémentation fournie de <code>HttpMessageHandler</code> est une classe abstraite nommée <code>DelegatingHandler</code>, et c'est de celle là que je voudrais parler.</p>
<h2 id="le-pipeline">Le pipeline</h2>
<p><code>DelegatingHandler</code> est un handler qui est conçu pour être chaîné à un autre handler, ce qui donne un pipeline à travers lequel les requêtes et réponses vont passer, comme illustré par ce schéma :
<img src="webapi_handlers_03.png" alt="Schéma du pipeline de HttpClient" title="Image tirée du site officiel ASP.NET">
(Image tirée du <a href="https://www.asp.net/web-api/overview/advanced/httpclient-message-handlers">site officiel ASP.NET</a>)</p>
<p>Chaque handler a la possibilité d'examiner et/ou de modifier la requête avant de la passer au handler suivant, et d'examiner et/ou de modifier la réponse reçue du handler suivant. Habituellement, le dernier handler dans le pipeline est le <code>HttpClientHandler</code>, qui communique directement avec le réseau.</p>
<p>La chaîne de handlers peut être configurée comme ceci :</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp"><span style="color:#66d9ef">var</span> pipeline = <span style="color:#66d9ef">new</span> MyHandler1()
{
    InnerHandler = <span style="color:#66d9ef">new</span> MyHandler2()
    {
        InnerHandler = <span style="color:#66d9ef">new</span> HttpClientHandler()
    }
};
<span style="color:#66d9ef">var</span> client = <span style="color:#66d9ef">new</span> HttpClient(pipeline);
</code></pre></div><p>Mais si vous préférez les interfaces &ldquo;fluent&rdquo;, il est facile de créer une méthode d'extension qui permet de le faire comme ceci :</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp"><span style="color:#66d9ef">var</span> pipeline = <span style="color:#66d9ef">new</span> HttpClientHandler()
    .DecorateWith(<span style="color:#66d9ef">new</span> MyHandler2())
    .DecorateWith(<span style="color:#66d9ef">new</span> MyHandler1());
<span style="color:#66d9ef">var</span> client = <span style="color:#66d9ef">new</span> HttpClient(pipeline);
</code></pre></div><p>Tout ça semble peut-être un peu abstrait pour l'instant, mais cette architecture à base de pipeline rend possible plein de scénarios intéressants. En effet, ces handlers de messages HTTP peuvent être utilisés pour ajouter des comportements personnalisés au traitement des requêtes et réponses. Je vais en donner quelques exemples.</p>
<p><strong>Remarque :</strong> Je présente cette fonctionnalité d'un point de vue client (vu que je développe essentiellement des applis clientes), mais le même système de handlers est également utilisé <a href="https://www.asp.net/web-api/overview/advanced/http-message-handlers">côté serveur dans ASP.NET Web API</a>.</p>
<h2 id="tests-unitaires">Tests unitaires</h2>
<p>Le premier cas d'utilisation qui vient à l'esprit, et le premier que j'ai mis en oeuvre, c'est les tests unitaires. Si vous testez une classe qui fait des paiements en ligne via HTTP, vous ne voulez pas que vos tests envoient réellement des requêtes au vrai serveur&hellip; Vous voulez juste vous assurer que les requêtes envoyées sont correctes, et que le code réagit correctement à des réponses spécifiques. Une solution simple à ce problème est de créer un handler &ldquo;stub&rdquo;, et de l'injecter dans votre classe à la place de <code>HttpClientHandler</code>. Voici une implémentation possible :</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">StubHandler</span> : HttpMessageHandler
{
    <span style="color:#75715e">// Responses to return
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">readonly</span> Queue&lt;HttpResponseMessage&gt; _responses =
        <span style="color:#66d9ef">new</span> Queue&lt;System.Net.Http.HttpResponseMessage&gt;();

    <span style="color:#75715e">// Requests that were sent via the handler
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">readonly</span> List&lt;HttpRequestMessage&gt; _requests =
        <span style="color:#66d9ef">new</span> List&lt;System.Net.Http.HttpRequestMessage&gt;();

    <span style="color:#66d9ef">protected</span> <span style="color:#66d9ef">override</span> Task&lt;HttpResponseMessage&gt; SendAsync(
        HttpRequestMessage request,
        CancellationToken cancellationToken)
    {
        <span style="color:#66d9ef">if</span> (_responses.Count == <span style="color:#ae81ff">0</span>)
            <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> InvalidOperationException(<span style="color:#e6db74">&#34;No response configured&#34;</span>);

        _requests.Add(request);
        <span style="color:#66d9ef">var</span> response = _responses.Dequeue();
        <span style="color:#66d9ef">return</span> Task.FromResult(response);
    }

    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> QueueResponse(HttpResponseMessage response) =&gt;
        _responses.Enqueue(response);

    <span style="color:#66d9ef">public</span> IEnumerable&lt;HttpRequestMessage&gt; GetRequests() =&gt;
        _requests;
}
</code></pre></div><p>Cette classe permet d'enregister les requêtes qui sont envoyées via le handler et de spécifier les réponses qui doivent être renvoyées. Par exemple, on pourrait écrire un test comme celui-ci :</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp"><span style="color:#75715e">// Arrange
</span><span style="color:#75715e"></span><span style="color:#66d9ef">var</span> handler = <span style="color:#66d9ef">new</span> StubHandler();
handler.EnqueueResponse(<span style="color:#66d9ef">new</span> HttpResponseMessage(HttpStatusCode.Unauthorized));
<span style="color:#66d9ef">var</span> processor = <span style="color:#66d9ef">new</span> PaymentProcessor(handler);

<span style="color:#75715e">// Act
</span><span style="color:#75715e"></span><span style="color:#66d9ef">var</span> paymentResult = <span style="color:#66d9ef">await</span> processor.ProcessPayment(<span style="color:#66d9ef">new</span> Payment());

<span style="color:#75715e">// Assert
</span><span style="color:#75715e"></span>Assert.AreEqual(PaymentStatus.Failed, paymentResult.Status);
</code></pre></div><p>Bien sûr, plutôt que de créer un stub manuellement, il est possible d'utiliser un framework de mock pour générer un faux handler. Le fait que la méthode <code>SendAsync</code> soit protégée rend cette approche un peu moins facile qu'elle devrait l'être, mais on peut facilement contourner le problème en créant une classe dérivée qui expose une méthode publique virtuelle, et en faisant un mock de cette classe :</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">abstract</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MockableMessageHandler</span> : HttpMessageHandler
{
    <span style="color:#66d9ef">protected</span> <span style="color:#66d9ef">override</span> <span style="color:#66d9ef">sealed</span> Task&lt;HttpResponseMessage&gt; SendAsync(
        HttpRequestMessage request,
        CancellationToken cancellationToken)
    {
        <span style="color:#66d9ef">return</span> DoSendAsync(request);
    }

    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">abstract</span> Task&lt;HttpResponseMessage&gt; DoSendAsync(HttpRequestMessage request);
}
</code></pre></div><p>Exemple d'utilisation avec <a href="https://github.com/FakeItEasy/FakeItEasy">FakeItEasy</a> :</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp"><span style="color:#75715e">// Arrange
</span><span style="color:#75715e"></span><span style="color:#66d9ef">var</span> handler = A.Fake&lt;MockableMessageHandler&gt;();
A.CallTo(() =&gt; handler.DoSendAsync(A&lt;HttpRequestMessage&gt;._))
    .Returns(<span style="color:#66d9ef">new</span> HttpResponseMessage(HttpStatusCode.Unauthorized));
<span style="color:#66d9ef">var</span> processor = <span style="color:#66d9ef">new</span> PaymentProcessor(handler);
...
</code></pre></div><h2 id="logging">Logging</h2>
<p>Écrire dans  le log les requêtes envoyées et les réponses reçues peut aider à diagnostiquer certains problèmes. C'est très facile à mettre en oeuvre avec un un <code>DelegatingHandler</code> personnalisé :</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">LoggingHandler</span> : DelegatingHandler
{
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">readonly</span> ILogger _logger;

    <span style="color:#66d9ef">public</span> LoggingHandler(ILogger logger)
    {
        _logger = logger;
    }

    <span style="color:#66d9ef">protected</span> <span style="color:#66d9ef">override</span> <span style="color:#66d9ef">async</span> Task&lt;HttpResponseMessage&gt; SendAsync(
        HttpRequestMessage request,
        CancellationToken cancellationToken)
    {
        _logger.Trace(<span style="color:#e6db74">$&#34;Request: {request}&#34;</span>);
        <span style="color:#66d9ef">try</span>
        {
            <span style="color:#75715e">// base.SendAsync calls the inner handler
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">var</span> response = <span style="color:#66d9ef">await</span> <span style="color:#66d9ef">base</span>.SendAsync(request, cancellationToken);
            _logger.Trace(<span style="color:#e6db74">$&#34;Response: {response}&#34;</span>);
            <span style="color:#66d9ef">return</span> response;
        }
        <span style="color:#66d9ef">catch</span> (Exception ex)
        {
            _logger.Error(<span style="color:#e6db74">$&#34;Failed to get response: {ex}&#34;</span>);
            <span style="color:#66d9ef">throw</span>;
        }
    }
}
</code></pre></div><h2 id="ressayer-les-requtes-choues">Réessayer les requêtes échouées</h2>
<p>Un autre cas d'utilisation intéressant des handlers de messages HTTP est de réessayer automatiquement les requêtes qui ont échouées. Par exemple, le serveur auquel on s'adresse peut être temporairement indisponible (503), il peut limiter nos requêtes (429), ou on peut tout simplement avoir perdu l'accès à internet. Dans toutes ces situations, réessayer la même requête plus tard a de bonnes chances de fonctionner (le serveur peut avoir redémarré, on peut avoir retrouvé du wifi&hellip;). Gérer la retentative au niveau du code applicatif est laborieux, car ça peut se produire pratiquement n'importe où. Avoir cette logique au plus bas niveau possible et implémentée d'une façon complètement transparente pour l'appelant rend les choses beaucoup plus simples.</p>
<p>Voici une implémentation possible d'un handler qui réessaie les requêtes échouées :</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">RetryHandler</span> : DelegatingHandler
{
    <span style="color:#66d9ef">protected</span> <span style="color:#66d9ef">override</span> <span style="color:#66d9ef">async</span> Task&lt;HttpResponseMessage&gt; SendAsync(
        HttpRequestMessage request,
        CancellationToken cancellationToken)
    {
        <span style="color:#66d9ef">while</span> (<span style="color:#66d9ef">true</span>)
        {
            <span style="color:#66d9ef">try</span>
            {
                <span style="color:#75715e">// base.SendAsync calls the inner handler
</span><span style="color:#75715e"></span>                <span style="color:#66d9ef">var</span> response = <span style="color:#66d9ef">await</span> <span style="color:#66d9ef">base</span>.SendAsync(request, cancellationToken);

                <span style="color:#66d9ef">if</span> (response.StatusCode == HttpStatusCode.ServiceUnavailable)
                {
                    <span style="color:#75715e">// 503 Service Unavailable
</span><span style="color:#75715e"></span>                    <span style="color:#75715e">// Wait a bit and try again later
</span><span style="color:#75715e"></span>                    <span style="color:#66d9ef">await</span> Task.Delay(<span style="color:#ae81ff">5</span><span style="color:#ae81ff">0</span><span style="color:#ae81ff">0</span><span style="color:#ae81ff">0</span>, cancellationToken);
                    <span style="color:#66d9ef">continue</span>;
                }

                <span style="color:#66d9ef">if</span> (response.StatusCode == (HttpStatusCode)<span style="color:#ae81ff">4</span><span style="color:#ae81ff">2</span><span style="color:#ae81ff">9</span>)
                {
                    <span style="color:#75715e">// 429 Too many requests
</span><span style="color:#75715e"></span>                    <span style="color:#75715e">// Wait a bit and try again later
</span><span style="color:#75715e"></span>                    <span style="color:#66d9ef">await</span> Task.Delay(<span style="color:#ae81ff">1</span><span style="color:#ae81ff">0</span><span style="color:#ae81ff">0</span><span style="color:#ae81ff">0</span>, cancellationToken);
                    <span style="color:#66d9ef">continue</span>;
                }

                <span style="color:#75715e">// Not something we can retry, return the response as is
</span><span style="color:#75715e"></span>                <span style="color:#66d9ef">return</span> response;
            }
            <span style="color:#66d9ef">catch</span> (Exception ex) when(IsNetworkError(ex))
            {
                <span style="color:#75715e">// Network error
</span><span style="color:#75715e"></span>                <span style="color:#75715e">// Wait a bit and try again later
</span><span style="color:#75715e"></span>                <span style="color:#66d9ef">await</span> Task.Delay(<span style="color:#ae81ff">2</span><span style="color:#ae81ff">0</span><span style="color:#ae81ff">0</span><span style="color:#ae81ff">0</span>, cancellationToken);
                <span style="color:#66d9ef">continue</span>;
            }
        }
    }

    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">bool</span> IsNetworkError(Exception ex)
    {
        <span style="color:#75715e">// Check if it&#39;s a network error
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> (ex <span style="color:#66d9ef">is</span> SocketException)
            <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span>;
        <span style="color:#66d9ef">if</span> (ex.InnerException != <span style="color:#66d9ef">null</span>)
            <span style="color:#66d9ef">return</span> IsNetworkError(ex.InnerException);
        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span>;
    }
}
</code></pre></div><p>Remarquez que cette implémentation est un peu simpliste ; pour l'utiliser dans du code de production, il faudra sans doute ajouter un &ldquo;exponential backoff&rdquo; (attendre de plus en plus longtemps entre chaque tentative), prendre en compte l'en-tête <code>Retry-After</code> pour déterminer combien de temps il faut attendre, ou encore déterminer de façon un peu plus subtile si une exception correspond à une erreur réseau. De plus, en l'état actuel, ce handler réessaiera <em>indéfiniment</em> jusqu'à ce que la requête réussisse ; assurez-vous donc de passer un jeton d'annulation (<code>CancellationToken</code>) pour pouvoir l'arrêter si besoin.</p>
<h2 id="autres-cas-dutilisations">Autres cas d'utilisations</h2>
<p>Je ne peux pas donner d'exemples pour chaque scénario possible, mais voilà quelques autres cas d'utilisation possible des handlers de messages HTTP :</p>
<ul>
<li>Gestion personnalisée des cookies (quelque chose que j'ai réellement fait, pour contourner un bug dans <code>CookieContainer</code>)</li>
<li>Authentification personnalisée (également quelque chose que j'ai fait, pour implémenter l'authentification OAuth2)</li>
<li>Utiliser l'en-tête <code>X-HTTP-Method-Override</code> pour passer les proxy qui refusent certaines méthode HTTP (voir <a href="http://www.hanselman.com/blog/HTTPPUTOrDELETENotAllowedUseXHTTPMethodOverrideForYourRESTServiceWithASPNETWebAPI.aspx">l'article de Scott Hanselman</a> pour plus de détails)</li>
<li>Chiffrement ou encodage personnalisé</li>
<li>Mise en cache</li>
<li>&hellip;</li>
</ul>
<p>Comme vous le voyez, il y a tout un monde de possibilités. Si vous avez d'autres idées, indiquez les dans les commentaires !</p>

		</div>
		<footer class="post__footer">
			
<div class="post__tags tags clearfix">
	<svg class="tags__badge icon icon-tag" width="16" height="16" viewBox="0 0 32 32"><path d="M32 19c0 1-1 2-1 2L21 31s-1 1-2 1-2-1-2-1L2 16c-1-1-1.4-2-1.4-2S0 12.5 0 11V3C0 1.5.8.8.8.8S1.5 0 3 0h8c1.5 0 3 .6 3 .6S15 1 16 2l15 15s1 1 1 2zM7 10a3 3 0 1 0 0-6 3 3 0 0 0 0 6z"/></svg>
	<ul class="tags__list">
		<li class="tags__item">
			<a class="tags__link btn" href="/tags/.net/" rel="tag">.NET</a>
		</li>
		<li class="tags__item">
			<a class="tags__link btn" href="/tags/c%23/" rel="tag">C#</a>
		</li>
		<li class="tags__item">
			<a class="tags__link btn" href="/tags/http/" rel="tag">HTTP</a>
		</li>
		<li class="tags__item">
			<a class="tags__link btn" href="/tags/httpclient/" rel="tag">HttpClient</a>
		</li>
		<li class="tags__item">
			<a class="tags__link btn" href="/tags/httpmessagehandler/" rel="tag">HttpMessageHandler</a>
		</li>
		<li class="tags__item">
			<a class="tags__link btn" href="/tags/pipeline/" rel="tag">pipeline</a>
		</li>
	</ul>
</div>
		</footer>
	</article>
</main>

<div class="authorbox clearfix">
	<figure class="authorbox__avatar">
		<img alt="Thomas Levesque avatar" src="/images/avatar.jpg" class="avatar" height="90" width="90">
	</figure>
	<div class="authorbox__header">
		<span class="authorbox__name">À propos Thomas Levesque</span>
	</div>
	<div class="authorbox__description">
		Thomas Levesque est un développeur français vivant à Paris.
	</div>
</div>

<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/2016/08/23/deconstruction-de-tuples-en-c-7/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Précédent</span>
			<p class="pager__title">Déconstruction de tuples en C# 7</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/2017/02/10/methodes-c-dans-les-en-tetes-de-diff-git/" rel="next">
			<span class="pager__subtitle">Suivant&thinsp;»</span>
			<p class="pager__title">Méthodes C# dans les en-têtes de diff git</p>
		</a>
	</div>
</nav>

<div>
    <script src="https://utteranc.es/client.js"
            repo="thomaslevesque/blog-fr"
            issue-term="pathname"
            label="post-comment"
            theme="github-light"
            crossorigin="anonymous"
            async>
    </script>
</div>


			</div>
			<aside class="sidebar"><div class="widget-search widget">
	<form class="widget-search__form" role="search" method="get" action="https://google.com/search">
		<label>
			<input class="widget-search__field" type="search" placeholder="Rechercher..." value="" name="q" aria-label="Rechercher...">
		</label>
		<input class="widget-search__submit" type="submit" value="Search">
		<input type="hidden" name="sitesearch" value="https://thomaslevesque.fr/" />
	</form>
</div>
<div class="widget-social widget">
    <h4 class="widget-social__title widget__title">Social</h4>
    <div class="widget-social__content widget__content">
        <a class="widget-social__link-custom widget__link" title="GitHub" rel="noopener noreferrer" href="https://github.com/thomaslevesque" target="_blank">
            <svg class="widget-social__link-icon-custom icon icon-github" width="24" height="24" viewBox="0 0 384 374"><path d="m192 0c-106.1 0-192 85.8-192 191.7 0 84.7 55 156.6 131.3 181.9 9.6 1.8 13.1-4.2 13.1-9.2 0-4.6-.2-16.6-.3-32.6-53.4 11.6-64.7-25.7-64.7-25.7-8.7-22.1-21.3-28-21.3-28-17.4-11.9 1.3-11.6 1.3-11.6 19.3 1.4 29.4 19.8 29.4 19.8 17.1 29.3 44.9 20.8 55.9 15.9 1.7-12.4 6.7-20.8 12.2-25.6-42.6-4.8-87.5-21.3-87.5-94.8 0-20.9 7.5-38 19.8-51.4-2-4.9-8.6-24.3 1.9-50.7 0 0 16.1-5.2 52.8 19.7 15.3-4.2 31.7-6.4 48.1-6.5 16.3.1 32.7 2.2 48.1 6.5 36.7-24.8 52.8-19.7 52.8-19.7 10.5 26.4 3.9 45.9 1.9 50.7 12.3 13.4 19.7 30.5 19.7 51.4 0 73.7-44.9 89.9-87.7 94.6 6.9 5.9 13 17.6 13 35.5 0 25.6-.2 46.3-.2 52.6 0 5.1 3.5 11.1 13.2 9.2 76.2-25.5 131.2-97.3 131.2-182 0-105.9-86-191.7-192-191.7z"/></svg>
        </a>
        <a class="widget-social__link-custom widget__link" title="Twitter" rel="noopener noreferrer" href="https://twitter.com/thomaslevesque" target="_blank">
            <svg class="widget-social__link-icon-custom icon icon-twitter" width="24" height="24" viewBox="0 0 384 312"><path d="m384 36.9c-14.1 6.3-29.3 10.5-45.2 12.4 16.3-9.7 28.8-25.2 34.6-43.6-15.2 9-32.1 15.6-50 19.1-14.4-15.2-34.9-24.8-57.5-24.8-43.5 0-78.8 35.3-78.8 78.8 0 6.2.7 12.2 2 17.9-65.5-3.3-123.5-34.6-162.4-82.3-6.7 11.6-10.6 25.2-10.6 39.6 0 27.3 13.9 51.4 35 65.6-12.9-.4-25.1-4-35.7-9.9v1c0 38.2 27.2 70 63.2 77.2-6.6 1.8-13.6 2.8-20.8 2.8-5.1 0-10-.5-14.8-1.4 10 31.3 39.1 54.1 73.6 54.7-27 21.1-60.9 33.7-97.8 33.7-6.4 0-12.6-.4-18.8-1.1 34.9 22.4 76.3 35.4 120.8 35.4 144.9 0 224.1-120 224.1-224.1 0-3.4-.1-6.8-.2-10.2 15.4-11.1 28.7-25 39.3-40.8z"/></svg>
        </a>
    </div>
</div>
<div class="widget-recent widget">
	<h4 class="widget__title">Articles récents</h4>
	<div class="widget__content">
		<ul class="widget__list">
			<li class="widget__item"><a class="widget__link" href="/2018/04/17/fin-de-mon-blog-en-francais/">Fin de mon blog en français</a></li>
			<li class="widget__item"><a class="widget__link" href="/2018/03/27/comprendre-le-pipeline-de-middleware-dasp-net-core/">Comprendre le pipeline de middleware d&#39;ASP.NET Core</a></li>
			<li class="widget__item"><a class="widget__link" href="/2018/03/06/nettoyer-lhistorique-dune-branche-git-pour-supprimer-les-fichiers-indesirables/">Nettoyer l&#39;historique d&#39;une branche Git pour supprimer les fichiers indésirables</a></li>
			<li class="widget__item"><a class="widget__link" href="/2018/02/25/meilleure-gestion-du-timeout-avec-httpclient/">Meilleure gestion du timeout avec HttpClient</a></li>
			<li class="widget__item"><a class="widget__link" href="/2017/11/14/transformer-les-templates-t4-pendant-la-build-et-passer-des-variables-du-projet/">Transformer les templates T4 pendant la build, et passer des variables du projet</a></li>
		</ul>
	</div>
</div>
<div class="widget-taglist widget">
	<h4 class="widget__title">Mots-clefs</h4>
	<div class="widget__content">
		<a class="widget-taglist__link widget__link btn" href="/tags/c%23/" title="c#">c#</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/wpf/" title="wpf">wpf</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/xaml/" title="xaml">xaml</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/visual-studio/" title="visual-studio">visual-studio</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/async/" title="async">async</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/binding/" title="binding">binding</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/markup-extension/" title="markup-extension">markup-extension</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/mvvm/" title="mvvm">mvvm</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/linq/" title="linq">linq</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/tests-unitaires/" title="tests-unitaires">tests-unitaires</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/winrt/" title="winrt">winrt</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/.net/" title=".net">.net</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/.net-4.0/" title=".net-4.0">.net-4.0</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/.net-core/" title=".net-core">.net-core</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/asynchrone/" title="asynchrone">asynchrone</a>
	</div>
</div>
</aside>
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2020 Thomas Levesque.
			<span class="footer__copyright-credits">Produit par <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> et le thème <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a>.</span>
		</div>
	</div>
</footer>
	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>