<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>asynchrone on Blog .NET de Thomas Levesque</title>
    <link>https://thomaslevesque.fr/tags/asynchrone/</link>
    <description>Recent content in asynchrone on Blog .NET de Thomas Levesque</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>fr-fr</language>
    <lastBuildDate>Tue, 04 Nov 2014 00:00:00 +0000</lastBuildDate><atom:link href="https://thomaslevesque.fr/tags/asynchrone/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Passage de paramètres par référence à une méthode asynchrone</title>
      <link>https://thomaslevesque.fr/2014/11/04/passing-parameters-by-reference-to-an-asynchronous-method/</link>
      <pubDate>Tue, 04 Nov 2014 00:00:00 +0000</pubDate>
      
      <guid>https://thomaslevesque.fr/2014/11/04/passing-parameters-by-reference-to-an-asynchronous-method/</guid>
      <description>L’asynchronisme dans C# est une fonctionnalité géniale, et je l’ai beaucoup utilisé depuis son apparition. Mais il y a quelques limitations agaçantes; par exemple, on ne peut pas passer des paramètres par référence (ref ou out) à une méthode asynchrone. Il y a de bonnes raisons pour cela; la plus évidente est que si vous passez par référence une variable locale, elle est stockée sur la pile, or la pile ne va pas rester disponible pendant toute l’exécution de la méthode asynchone (seulement jusqu’au premier await), donc l’emplacement de la variable n’existera plus.</description>
    </item>
    
    <item>
      <title>[WPF] Binding sur une collection asynchrone</title>
      <link>https://thomaslevesque.fr/2009/04/17/wpf-binding-sur-une-collection-asynchrone/</link>
      <pubDate>Fri, 17 Apr 2009 00:00:00 +0000</pubDate>
      
      <guid>https://thomaslevesque.fr/2009/04/17/wpf-binding-sur-une-collection-asynchrone/</guid>
      <description>Comme je l&amp;rsquo;avais évoqué dans mon précédent post, on ne peut pas ajouter des éléments à une ObservableCollection à partir d&amp;rsquo;un autre thread si une vue est bindée sur la collection : cela provoque une NotSupportedException. Prenons l&amp;rsquo;exemple d&amp;rsquo;une ListBox bindée sur une collection de chaines de caractères appartenant au ViewModel :
 private ObservableCollection&amp;lt;string&amp;gt; _strings = new ObservableCollection&amp;lt;string&amp;gt;();  public ObservableCollection&amp;lt;string&amp;gt; Strings  {  get { return _strings; }  set  {  _strings = value;  OnPropertyChanged(&amp;#34;Strings&amp;#34;);  }  } &amp;lt;ListBox ItemsSource=&amp;#34;{Binding Strings}&amp;#34;/&amp;gt; Si on ajoute des éléments à cette collection hors du thread principal, on obtient l&amp;rsquo;exception citée plus haut.</description>
    </item>
    
    <item>
      <title>[WPF] Binding asynchrone sur une propriété du ViewModel</title>
      <link>https://thomaslevesque.fr/2009/04/01/wpf-binding-asynchrone-sur-une-propriete-du-viewmodel/</link>
      <pubDate>Wed, 01 Apr 2009 00:00:00 +0000</pubDate>
      
      <guid>https://thomaslevesque.fr/2009/04/01/wpf-binding-asynchrone-sur-une-propriete-du-viewmodel/</guid>
      <description>Mise à jour : Comme l&amp;rsquo;a très justement indiqué Jérémy en commentaire, la propriété IsAsync du Binding permet de faire à peu près la même chose beaucoup plus simplement&amp;hellip; Bien que ma méthode puisse servir pour certains besoins spécifiques, dans la plupart des cas la propriété IsAsync est probablement le meilleur choix ! Je laisse le billet malgré tout, ne serait-ce que pour la classe SwitchBinding qui me semble assez utile&amp;hellip; J&amp;rsquo;ai eu récemment besoin, dans une application basée sur le pattern MVVM, d&amp;rsquo;afficher une propriété dont la valeur était assez longue à obtenir (récupérer par une requête HTTP).</description>
    </item>
    
  </channel>
</rss>
