<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>weak event on Blog .NET de Thomas Levesque</title>
    <link>https://thomaslevesque.fr/tags/weak-event/</link>
    <description>Recent content in weak event on Blog .NET de Thomas Levesque</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>fr-fr</language>
    <lastBuildDate>Sun, 16 Aug 2015 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://thomaslevesque.fr/tags/weak-event/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Weak events en C#, suite</title>
      <link>https://thomaslevesque.fr/2015/08/16/weak-events-en-c-suite/</link>
      <pubDate>Sun, 16 Aug 2015 00:00:00 +0000</pubDate>
      
      <guid>https://thomaslevesque.fr/2015/08/16/weak-events-en-c-suite/</guid>
      <description>Il y a quelques années, j’ai blogué à propos d’une implémentation générique du pattern “weak event” en C#. Le but était de pallier les problèmes de fuites mémoire liés aux évènements quand on oublie de s’en désabonner. L’implémentation était basée sur l’utilisation de références faibles sur les abonnés, de façon à éviter d’empêcher qu’ils soient libérés par le garbage collector.
Ma solution initiale était plus une preuve de concept qu’autre chose, et avait un sérieux problème de performance, dû à l’utilisation de DynamicInvoke à chaque fois que l’évènement était déclenché.</description>
    </item>
    
    <item>
      <title>[C#] Une implémentation du pattern WeakEvent</title>
      <link>https://thomaslevesque.fr/2010/05/16/c-une-implementation-du-pattern-weakevent/</link>
      <pubDate>Sun, 16 May 2010 00:00:00 +0000</pubDate>
      
      <guid>https://thomaslevesque.fr/2010/05/16/c-une-implementation-du-pattern-weakevent/</guid>
      <description>Comme vous le savez peut-être, la mauvaise utilisation des évènements est l&#39;une des principales causes de fuites mémoires dans une application .NET : en effet, un évènement garde des références aux objets qui y sont abonnés (via le delegate), ce qui empêche le garbage collector de collecter ces objets quand ils ne sont plus utilisés. Le problème est particulièrement vrai pour un évènement statique, puisque les références sont conservées pendant toute l&#39;exécution de l&#39;application.</description>
    </item>
    
  </channel>
</rss>